 ;
 ;
 ; PROGRAM: SDK-85 MONITOR VER 2.1
 ;
 ; COPYRIGHT (C) 1977
 ; INTEL CORPORATION
 ; 3065 BOWERS AVENUE
 ; SANTA CLARA, CALIFORNIA 95051
 ;
 ;
 ;
 ; ABSTRACT
 ;
 ;
 ; THIS PROGRAM IS A SMALL MONITOR FOR THE INTEL 8085 KIT AND
 ; PROVIDES A MINIMUM LEVEL OF UTILITY FUNCTIONS FOR THE USER EMPLOYING
 ; EITHER AN INTER-ACTIVE CONSOLE (I.E. TELETYPE) OR THE KIT'S
 ; KEYBOARD/LED DISPLAY. THE KEYBOARD MONITOR ALLOWS THE USER TO PERFORM
 ; SUCH FUNCTIONS AS MEMORY AND REGISTER MANIPULATION, PROGRAM LOADING,
 ; PROGRAM EXECUTION, INTERRUPTION OF AN EXECUTING PROGRAM, AND
 ; SYSTEM RESET.
 ;
 ; PROGRAM ORGANIZATION
 ; ======= ============
 ;
 ; THE PROGRAM IS ORGANIZED AS FOLLOWS :-
 ;       1) COLD START ROUTINE (RESET)
 ;       2) WARM START - REGISTER SAVE ROUTINE
 ;       3) INTERRUPT VECTORS
 ;       4) KEYBOARD MONITOR
 ;       5) TTY MONITOR
 ;       6) LAYOUT OF RAM USAGE
 ;
 ; THE KEYBOARD MONITOR BEGINS WITH THE COMMAND RECOGNIZER, FOLLOWED BY
 ; THE COMMAND ROUTINE SECTION, UTILITY ROUTINE SECTION AND MONITOR
 ; TABLES. THE COMMAND AND UTILITY ROUTINES ARE IN ALPHABETICAL ORDER
 ; WITHIN THEIR RESPECTIVE SECTIONS.
 ; THROUGHOUT THE KEYBOARD MONITOR, A COMMENT FIELD BEGINNING
 ; WITH "ARG - " INDICATES A STATEMENT WHICH LOADS A VALUE INTO
 ; A REGISTER AS AN ARGUMENT FOR A FUNCTION. WHEN THE DESIRED VALUE
 ; LIST OF KEYBOARD MONITOR ROUTINES
 ; ==== == ======== ======= ========
 ;
 ; CMMND
 ;
 ; EXAM
 ; GOCMD
 ; SSTEP
 ; SUBST
 ;
 ; CLEAR
 ; CLDIS
 ; CLDST
 ; DISPC
 ; ERR
 ; GTHEX
 ; HXDSP
 ; ININT
 ; INSDG
 ; NXTRG
 ; OUTPT
 ; RDKBD
 ; RETF
 ; RETT
 ; RGLOC
 ; RSTOR
 ; SETRG
 ; UPDAD
 ; UPDDT
 ;
 ; TODO Implement NAME Directive and then uncomment this line.
 ;       NAME    SDK85
 ;
 ;
 ;
 ; SET CONDITIONAL ASSEMBLY FLAG
 ;
 ;
 ;
 ;
 WAITS   SET      0       ; 0=NO WAIT STATES
                          ; 1=A WAIT STATE IS GENERATED FOR EVERY M CYCLE
                          ; THE APPROPRIATE DELAY TIME MUST BE USED FOR
                                      ; TTY DELAY OR SET UP SINGLE
                                      ; STEP TIMER FOR EACH CASE
 ;
 ;
 ;
 ;
 ; MONITOR EQUATES
 ;
 ;
 ;
 RAMST   EQU      2000H   ; START ADDRESS OF RAM - THIS PROGRAM ASSUMES
 ; THAT 256 BYTES OF RANDOM ACCESS MEMORY BEGIN AT THIS ADDRESS.
 ; THE PROGRAM USES STORAGE AT THE END OF THIS SPACE FOR VARIABLES,
 ; SAVING REGISTERS AND THE PROGRAM STACK
 ;
 RMUSE   EQU      23      ; RAM USAGE - CURRENTLY, 23 BYTES ARE USED FOR
                          ; /SAVING REGISTERS AND VARIABLES
 ;
 SKLN    EQU      24      ; MONITOR STACK USAGE - MAX OF 12 LEVELS
 ;
 UBRLN   EQU      15      ; 5 USER BRANCHES - 3 BYTES EACH
 ;
 ADFLD   EQU      0       ; INDICATES USE OF ADDRESS FIELD OF DISPLAY
 ADISP   EQU      90H     ; CONTROL CHARACTER TO INDICATE OUTPUT TO
                          ; /ADDRESS FIELD OF DISPLAY
 CNTRL   EQU      1900H   ; ADDRESS FOR SENDING CONTROL CHARACTERS TO
                          ; /DISPLAY CHIP
 COMMA   EQU      11H     ; COMMA FROM KEYBOARD
 CSNIT   EQU      0       ; INITIAL VALUE FOR COMMAND STATUS REGISTER
 CSR     EQU      20H     ; OUTPUT PORT FOR COMMAND STATUS REGISTER
 DDISP   EQU      94H     ; CONTROL CHARACTER TO INDICATE OUTPUT TO
                          ; /DATA FIELD OF DISPLAY
 DOT     EQU      1       ; INDICATOR FOR DOT IN DISPLAY
 DSPLY   EQU      1800H   ; ADDRESS FOR SENDING CHARACTERS TO DISPLAY
 DTFLD   EQU      1       ; INDICATES USE OF DATA FIELD OF DISPLAY
 DTMSK   EQU      08H     ; MASK FOR TURNING ON DOT IN DISPLAY
 EMPTY   EQU      80H     ; HIGH ORDER 1 INDICATES EMPTY INPUT BUFFER
 KBNIT   EQU      0CCH    ; CONTROL CHARACTER TO SET DISPLAY OUTPUT TO
                          ; /ALL ONES DURING BLANKING PERIOD
 KMODE   EQU      0       ; CONTROL CHAR. TO SET KEYBOARD/DISPLAY MODE
                          ; (2 KEY ROLLOVER, 8 CHARACTER LEFT ENTRY)
 MNSTK   EQU      RAMST + 256 - RMUSE ; START OF MONITOR STACK
 NODOT   EQU      0       ; INDICATOR FOR NO DOT IN DISPLAY
 ; NUMC    -        DEFINED LATER ; NUMBER OF COMMANDS
 ; NUMRG   -        DEFINED LATER ; NUMBER OF REGISTER SAVE LOCATIONS
 PERIO   EQU      10H     ; PERIOD FROM KEYBOARD
 PRMPT   EQU      0FBH    ; PROMPT CHARACTER FOR DISPLAY (DASH)
 READ    EQU      40H     ; CONTROL CHARACTER TO INDICATE INPUT FROM
                          ; /KEYBOARD
 TIMHI   EQU      25H     ; OUTPUT PORT FOR HIGH ORDER BYTE OF TIMER VALUE
 TIMLO   EQU      24H     ; OUTPUT PORT FOR LOW ORDER BYTE OF TIMER VALUE
 TMODE   EQU      40H     ; TIMER MODE - SQUARE WAVE, AUTO RELOAD
 TSTRT   EQU      0C0H    ; START TIMER
 UNMSK   EQU      0EH     ; UNMASK INPUT INTERRUPT
 USRBR   EQU      RAMST + 256 - (RMUSE + SKLN + UBRLN) ; START OF USER
                          ; /BRANCH LOCATIONS
         IF       1-WAITS ; TIMER VALUE FOR SINGLE STEP IF NO WAIT STATE
 TIMER   EQU      197
         ENDIF
         IF       WAITS   ; TIMER VALUE FOR SINGLE STEP IF ONE WAIT STATE INSERTED
 TIMER   EQU      237
         ENDIF
 ;
 ;
 ;
 ; MONITOR MACROS
 ;
 ;
 ;
 TRUE    MACRO   WHERE ; BRANCH IF FUNCTION RETURNS TRUE
         JC      WHERE
         ENDM
 ;
 FALSE   MACRO   WHERE ; BRANCH IF FUNCTION RETURNS FALSE
         JNC     WHERE
         ENDM
 ;
 ;
 ;
 ;
 ; "RESET" KEY ENTRY POINT - COLD START
 ; RST 0 ENTRY POINT
 ;
         MVI     A,KMODE  ; GET CONTROL CHARACTER
         STA     CNTRL    ; SET KEYBOARD/DISPLAY MODE
         JMP     CLDST    ; GO FINISH COLD START
 CLDBK:                   ; THEN JUMP BACK HERE
 ;
 ; RST 1 ENTRY POINT - WARM START
 ;
         ORG     8
 ; SAVE REGISTERS
         SHLD    LSAV     ; SAVE H & L REGISTERS
         POP     H        ; GET USER PROGRAM COUNTER FROM TOP OF STACK
         SHLD    PSAV     ; /AND SAVE IT
         PUSH    PSW
         POP     H
         SHLD    FSAV     ; SAVE FLIP/FLOPS & REGISTER A
         LXI     H,0      ; CLEAR H & L
         DAD     SP       ; GET USER STACK POINTER
         SHLD    SSAV     ; /AND SAVE IT
         LXI     H,BSAV+1 ; SET STACK POINTER FOR SAVING
         SPHL             ; /REMAINING REGISTERS
         PUSH    B        ; SAVE B & c
         PUSH    D        ; SAVE D & E
         JMP     RES10    ; LEAVE ROOM FOR VECTORED INTERRUPTS
 ;
 ; TIMER INTERRUPT (TRAP) ENTRY POINT (RST 4.5)
         ORG     24H
         JMP     STP25    ; BACK TO SINGLE STEP ROUTINE
 ;
 ; RST 5 ENTRY POINT
 ;
         ORG     28H
         JMP     RSET5    ; BRANCH TO RST 5 LOCATION IN RAM
 ;
 ; INPUT INTERRUPT ENTRY POINT (RST 5.5)
 ;
         ORG     2CH
         JMP     ININT    ; BRANCH TO INPUT INTERRUPT ROUTINE
 ;
 ; RST 6 ENTRY POINT
 ;
         ORG     30H
         JMP     RSET6    ; BRANCH TO RST 6 LOCATION IN RAM
 ;
 ; HARD WIRED USER INTERRUPT ENTRY POINT (RST 6.5)
 ;
         ORG     34H
         JMP     RST65    ; BRANCH TO RST 6.5 LOCATION IN RAM
 ;
 ; RST 7 ENTRY POINT
 ;
         ORG     38H
         JMP     RSET7    ; BRANCH TO RST 7 LOCATION IN RAM
 ;
 ; "VECTORED INTERRUPT" KEY ENTRY POINT (RST 7.5)
         ORG     3CH
         JMP     USINT    ; BRANCH TO USER INTERRUPT LOCATION IN RAM
 ;
 RES10:                   ; CONTINUE SAVING USER STATUS
         RIM              ; GET USER INTERRUPT STATUS AND INTERRUPT MASK
         ANI     0FH      ; KEEP STATUS & MASK BITS
         STA     ISAV     ; SAVE INTERRUPT STATUS & MASK
         MVI     A,UNMSK  ; UNMASK INTERRUPTS FOR MONITOR USE
         SIM
         DI               ; INTERRUPTS DISABLED WHILE MONITOR IS RUNNING
                          ; (EXCEPT WHEN WAITING FOR INPUT)
         RIM              ; TTY OR KEYBOARD MONITOR ?
         RLC              ; IS TTY CONNECTED ?
         JC      GO       ; YES - BRANCH TO TTY MONITOR
                          ; NO - ENTER KEYBOARD MONITOR
 ;
 ;
 ;
 ; BEGINNING OF KEYBOARD MONITOR CODE
 ;
 ;
 ;
 ; OUTPUT SIGN-ON MESSAGE
         XRA     A        ; ARG - USE ADDRESS FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         LXI     H,SGNAD  ; ARG - GET ADDRESS OF ADDRESS FIELD PORTION OF
                          ; /SIGN-ON MESSAGE
         CALL    OUTPT    ; OUTPUT SIGN-ON MESSAGE TO ADDRESS FIELD
         MVI     A,DTFLD  ; ARG - USE DATA FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN DATA FIELD
         LXI     H,SGNDT  ; ARG - GET ADDRESS OF DATA FIELD PORTION OF
                          ; /SIGN-ON MESSAGE
         CALL    OUTPT    ; OUTPUT SIGN-ON MESSAGE TO DATA FIELD
         MVI     A,EMPTY
         STA     IBUFF    ; SET INPUT BUFFER EMPTY FLAG
 ;
 ;
 ;
 ; FUNCTION: CMMND - COMMAND RECOGNIZER
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: RDKBD,ERR,SUBST,EXAM,GOCMD,SSTEP
 ; DESTROYS:
 ;
 CMMND:
         LXI     H,MNSTK  ; INITIALIZE MONITOR STACK POINTER
         SPHL
                          ; OUTPUT PROMPT CHARACTER TO DISPLAY
         LXI     H,CNTRL  ; GET ADDRESS FOR CONTROL CHARACTER
         MVI     M,ADISP  ; OUTPUT CONTROL CHARACTER TO USE ADDRESS FIELD
         DCR     H        ; ADDRESS FOR OUTPUT CHARACTER
         MVI     M,PRMPT  ; OUTPUT PROMPT CHARACTER
         CALL    RDKBD    ; READ KEYBOARD
         LXI     B,NUMC   ; COUNTER FOR NUMBER OF COMMANDS IN C
         LXI     H,CMDTB  ; GET ADDRESS OF COMMAND TABLE
 CMD10:
         CMP     M        ; RECOGNIZE THE COMMAND ?
         JZ      CMD15    ; YES - GO PROCESS IT
         INX     H        ; NO - NEXT COMMAND TABLE ENTRY
         DCR     C        ; END OF TABLE ?
         JNZ     CMD10    ; NO - GO CHECK NEXT ENTRY
                          ; YES - COMMAND UNKNOWN
         JMP     ERR      ; DISPLAY ERROR MESSAGE AND GET ANOTHER COMMAND
 CMD15:
         LXI     H,CMDAD  ; GET ADDRESS OF COMMAND ADDRESS TABLE
         DCR     C        ; ADJUST COMMAND COUNTER
                          ; COUNTER ACTS AS POINTER TO COMMAND ADDRESS TABLE
         DAD     B        ; ADD POINTER TO TABLE ADDRESS TWICE BECAUSE
         DAD     B        ; TABLE HAS 2 BYTE ENTRIES
         MOV     A,M      ; GET LOW ORDER BYTE OF COMMAND ADDRESS
         INX     H
         MOV     H,M      ; GET HIGH ORDER BYTE OF COMMAND ADDRESS IN H
         MOV     L,A      ; PUT LOW ORDER BYTE IN L
                          ; COMMAND ROUTINE ADDRESS IS NOW IN H & L
         PCHL             ; BRANCH TO ADDRESS IN H & L
 ;
 ;
 ;
 ; COMMAND ROUTINES
 ;
 ;
 ;
 ; FUNCTION: EXAM - EXAMINE AND MODIFY REGISTERS
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: CLEAR,SETRG,ERR,RGNAM,RGLOC,UPDDT,GTHEX,NXTRG
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ;
 EXAM:
         MVI     B,DOT    ; ARG - DOT IN ADDRESS FIELD OF DISPLAY
         CALL    CLEAR    ; CLEAR DISPLAY
         CALL    SETRG    ; GET REGISTER DESIGNATOR FROM KEYBOARD AND
                          ; /SET REGISTER POINTER ACCORDINGLY
                          ; WAS CHARACTER A REGISTER DESIGNATOR?
         FALSE   ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         JNC     ERR
 EXM05:
         CALL    RGNAM    ; OUTPUT REGISTER NAME TO ADDRESS FIELD
         CALL    RGLOC    ; GET REGISTER SAVE LOCATION IN H & L
         MOV     A,M      ; GET REGISTER CONTENTS
         STA     CURDT    ; STORE REGISTER CONTENTS AT CURRENT DATA
         MVI     B,DOT    ; ARG - DOT IN DATA FIELD
         CALL    UPDDT    ; UPDATE DATA FIELD OF DISPLAY
         MVI     B,DTFLD  ; ARG - USE DATA FIELD OF DISPLAY
         CALL    GTHEX    ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED?
         FALSE   EXM10    ; NO - DO NOT UPDATE REGISTER CONTENTS
         JNC     EXM10
         CALL    RGLOC    ; YES - GET REGISTER SAVE LOCATION IN H & L
         MOV     M,E      ; UPDATE REGISTER CONTENTS
 EXM10:
         CPI     PERIO    ; WAS LAST CHARACTER A PERIOD ?
         JZ      CLDIS    ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
         CPI     COMMA    ; WAS LAST CHARACTER ',' ?
         JNZ     ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         CALL    NXTRG    ; YES - ADVANCE REGISTER POINTER TO
                          ; /NEXT REGISTER
                          ; ANY MORE REGISTERS ?
         TRUE    EXM05    ; YES - CONTINUE PROCESSING WITH NEXT REGISTER
         JC      EXM05
         JMP     CLDIS    ; NO - CLEAR DISPLAY AND TERMINATE COMMAND
 ;
 ;
 ;
 ; FUNCTION: GOCMD - EXECUTE USER PROGRAM
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: DISPC,RDKBD,CLEAR,GTHEX,ERR,OUTPT
 ; DESTROYS:
 ;
 GOCMD:
         CALL    DISPC    ; DISPLAY USER PROGRAM COUNTER
         CALL    RDKBD    ; READ FROM KEYBOARD
         CPI     PERIO    ; IS CHARACTER A PERIOD ?
         JZ      G10      ; YES - GO EXECUTE THE COMMAND
                          ; NO - ARG - CHARACTER IS STILL IN A
         STA     IBUFF    ; REPLACE CHARACTER IN INPUT BUFFER
         MVI     B,DOT    ; ARG - DOT IN ADDRESS FIELD
         CALL    CLEAR    ; CLEAR DISPLAY
         MVI     B,ADFLD  ; ARG - USE ADDRESS FIELD
         CALL    GTHEX    ; GET HEX DIGITS
         CPI     PERIO    ; WAS LAST CHARACTER A PERIOD ?
         JNZ     ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         XCHG             ; PUT HEX VALUE FROM GTHEX TO H & L
         SHLD    PSAV     ; HEX VALUE IS NEW USER PC
 G10:
         MVI     B,NODOT  ; YES - ARG - NO DOT IN ADDRESS FIELD
         CALL    CLEAR    ; CLEAR DISPLAY
         XRA     A        ; ARG - USE ADDRESS FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         LXI     H,EXMSG  ; GET ADDRESS OF EXECUTION MESSAGE IN H & L
         CALL    OUTPT    ; DISPLAY EXECUTION MESSAGE
         JMP     RSTOR    ; RESTORE USER REGISTERS INCL. PROGRAM COUNTER
                          ; /I.E. BEGIN EXECUTION OF USER PROGRAM
 ;
 ;
 ;
 ; FUNCTION: SSTEP - SINGLE STEP (EXECUTE ONE USER INSTRUCTION)
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: DISPC,RDKBD,CLEAR,GTHEX,ER
 ; DESTROYS:
 ;
 SSTEP:
         CALL    DISPC    ; DISPLAY USER PROGRAM COUNTER
         CALL    RDKBD    ; READ FROM KEYBOARD
         CPI     PERIO    ; WAS CHARACTER A PERIOD ?
         JZ      CLDIS    ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
         CPI     COMMA    ; WAS LAST CHARACTER ',' ?
         JZ      STP20    ; YES - GO SET TIMER
                          ; NO - CHARACTER FROM KEYBOARD WAS NEITHER PERIOD NOR COMMA
         STA     IBUFF    ; REPLACE THE CHARACTER IN THE INPUT BUFFER
         MVI     B,DOT    ; ARG - DOT IN ADDRESS FIELD
         CALL    CLEAR    ; CLEAR DISPLAY
         MVI     B,ADFLD  ; ARG - USE ADDRESS FIELD OF DISPLAY
         CALL    GTHEX    ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED ?
         FALSE   ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         JNC     ERR
         XCHG             ; HEX VALUE FROM GTHEX TO H & L
         SHLD    PSAV     ; HEX VALUE IS NEW USER PC
         CPI     PERIO    ; WAS LAST CHARACTER FROM GTHEX A PERIOD ?
         JZ      CLDIS    ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
                          ; NO - MUST HAVE BEEN A COMMA
 STP20:
         LDA     ISAV     ; GET USER INTERRUPT MASK
         ANI     08H      ; KEEP INTERRUPT STATUS
         STA     TEMP     ; SAVE USER INTERRUPT STATUS
         LHLD    PSAV     ; GET USER PC
         MOV     A,M      ; GET USER INSTRUCTION
         CPI     (DI)     ; DI INSTRUCTION ?
         JNZ     STP21    ; NO
         XRA     A        ; YES - RESET USER INTERRUPT STATUS
         JMP     STP22
 STP21:
         CPI     (EI)     ; EI INSTRUCTION ?
         JNZ     STP23    ; NO
         MVI     A,08H    ; YES - SET USER INTERRUPT STATUS
 STP22:
         STA     TEMP     ; SAVE NEW USER INTERRUPT STATUS
 STP23:
         MVI     A,(TIMER SHR 8) OR TMODE ; HIGH ORDER BITS OF TIMER VALUE
                          ; /OR'ED WITH TIMER MODE
         OUT     TIMHI
         MVI     A,TIMER AND 0FFH ; LOW ORDER BITS OF TIMER VALUE
         OUT     TIMLO
         LDA     USCSR    ; GET USER IMAGE OF WHAT'S IN CSR
         ORI     TSTRT    ; SET TIMER COMMAND BITS TO START TIMER
         OUT     CSR      ; START TIMER
         JMP     RSTOR    ; RESTORE USER REGISTERS
 ;
 STP25:                   ; BRANCH HERE WHEN TIMER INTERRUPTS AFTER
                          ; /ONE USER INSTRUCTION
         PUSH    PSW      ; SAVE PSW
         LDA     USCSR    ; GET USER IMAGE OF WHAT'S IN CSR
         ANI     3FH      ; CLEAR 2 HIGH ORDER BITS
         ORI     40H      ; SET TIMER STOP BIT
         OUT     CSR      ; STOP TIMER
         POP     PSW      ; RETRIEVE PSW
         SHLD    LSAV     ; SAVE H & L
         POP     H        ; GET USER PROGRAM COUNTER FROM TOP OF STACK
         SHLD    PSAV     ; SAVE USER PC
         PUSH    PSW
         POP     H
         SHLD    FSAV     ; SAVE FLIP/FLOPS AND A REGISTER
         LXI     H,0      ; CLEAR H & L
         DAD     SP       ; GET USER STACK POINTER
         SHLD    SSAV     ; SAVE USER STACK POINTER
         LXI     H,BSAV+1 ; SET MONITOR STACK POINTER FOR
         SPHL             ; /SAVING REMAINING USER REGISTERS
         PUSH    B        ; SAVE B & C
         PUSH    D        ; SAVE D & E
         RIM              ; GET USER INTERRUPT MASK
         ANI     07H      ; KEEP MASK BITS
         LXI     H,TEMP   ; GET USER INTERRUPT STATUS
         ORA     M        ; OR IT INTO MASK
         STA     ISAV     ; SAVE INTERRUPT STATUS & MASK
         MVI     A,UNMSK  ; UNMASK INTERRUPTS FOR MONITOR USE
         SIM
         JMP     SSTEP    ; GO GET READY FOR ANOTHER INSTRUCTION
 ;
 ;
 ;
 ; FUNCTION: SUBST - SUBSTITUTE MEMORY
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: CLEAR,GTHEX,UPDAD,UPDDT,ERR
 ; DESTROYS:
 ;
 SUBST:
         MVI     B,DOT    ; ARG - DOT IN ADDRESS FIELD
         CALL    CLEAR    ; CLEAR THE DISPLAY
         MVI     B,ADFLD  ; ARG - USE ADDRESS FIELD OF DISPLAY
         CALL    GTHEX    ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED?
         FALSE   ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         JNC     ERR
         XCHG             ; ASSIGN HEX VALUE RETURNED BY GTHEX TO
         SHLD    CURAD    ; /CURRENT ADDRESS
 SUB05:
         CPI     COMMA    ; WAS ',' THE LAST CHARACTER FROM KEYBOARD?
         JNZ     SUB15    ; NO - GO TERMINATE THE COMMAND
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         CALL    UPDAD    ; UPDATE ADDRESS FIELD OF DISPLAY
         LHLD    CURAD    ; GET CURRENT ADDRESS IN H & L
         MOV     A,M      ; GET DATA BYTE POINTED TO BY CURRENT ADDRESS
         STA     CURDT    ; STORE DATA BYTE AT CURRENT DATA
         MVI     B,DOT    ; ARG - DOT IN DATA FIELD
         CALL    UPDDT    ; UPDATE DATA FIELD OF DISPLAY
         MVI     B,DTFLD  ; ARG - USE DATA FIELD
         CALL    GTHEX    ; GET HEX DIGITS - WERE ANY HEX DIGITS RECEIVED?
         PUSH    PSW      ; (SAVE LAST CHARACTER)
         FALSE   SUB10    ; NO - LEAVE DATA UNCHANGED AT CURRENT ADDRESS
         JNC     SUB10
         LHLD    CURAD    ; YES - GET CURRENT ADDRESS IN H & L
         MOV     M,E      ; STORE NEW DATA AT CURRENT ADDRESS
                          ; MAKE SURE DATA WAS ACTUALLY STORED IN CASE
                          ; /CURRENT ADDRESS IS IN ROM OR IS NON-EXISTANT
         MOV     A,E      ; DATA TO A FOR COMPARISON
         CMP     M        ; WAS DATA STORED CORRECTLY?
         JNZ     ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
 SUB10:
         LHLD    CURAD    ; INCREMENT CURRENT ADDRESS
         INX     H
         SHLD    CURAD
         POP     PSW      ; RETRIEVE LAST CHARACTER
         JMP     SUB05    ;
 SUB15:
         CPI     PERIO    ; WAS LAST CHARACTER '.' ?
         JNZ     ERR      ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
         JMP     CLDIS    ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
 ;
 ;
 ;
 ;
 ; UTILITY ROUTINES
 ;
 ;
 ;
 ; FUNCTION: CLEAR - CLEAR THE DISPLAY
 ; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT IN ADDRESS FIELD OF DISPLAY
 ;                      - 0 MEANS NO DOT
 ; OUTPUTS: NONE
 ; CALLS: OUTPT
 ; DESTROYS:
 ; DESCRIPTION: CLEAR SENDS BLANK CHARACTERS TO BOTH THE ADDRESS FIELD
 ;              AND THE DATA FIELD OF THE DISPLAY. IF THE DOT FLAG IS
 ;              SET THEN A DOT WILL APPEAR AT THE RIGHT EDGE OF THE
 ;              ADDRESS FIELD.
 ;
 CLEAR:
         XRA     A        ; ARG - USE ADDRESS FIELD OF DISPLAY
                          ; ARG - FLAG FOR DOT IN ADDR. FIELD IS IN B
         LXI     H,BLNKS  ; ARG - ADDRESS OF BLANKS FOR DISPLAY
         CALL    OUTPT    ; OUTPUT BLANKS TO ADDRESS FIELD
         MVI     A,DTFLD  ; ARG - USE DATA FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN DATA FIELD
         LXI     H,BLNKS  ; ARG - ADDRESS OF BLANKS FOR DISPLAY
         CALL    OUTPT    ; OUTPUT BLANKS TO DATA FIELD
         RET              ; RETURN
 ;
 ;
 ;
 ; FUNCTION: CLDIS - CLEAR DISPLAY AND TERMINATE COMMAND
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: CLEAR
 ; DESTROYS:
 ; DESCRIPTION: CLDIS IS JUMPED TO BY COMMAND ROUTINES WISHING TO
 ;              TERMINATE NORMALLY. CLDIS CLEARS THE DISPLAY AND
 ;              BRANCHES TO THE COMMAND RECOGNIZER.
 ;
 CLDIS:
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         CALL    CLEAR    ; CLEAR THE DISPLAY
         JMP     CMMND    ; GO GET ANOTHER COMMAND
 ;
 ;
 ;
 ; FUNCTION: CLDST - COLD START
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: NOTHING
 ; DESTROYS: A
 ; DESCRIPTION: CLDST IS JUMPED TO BY THE MAIN COLD START PROCEDURE,
 ;              COMPLETES COLD START INITIALIZATION, AND JUMPS BACK
 ;              TO THE MAIN COLD START PROCEDURE.
 ;
 CLDST:
         MVI     A,KBNIT  ; GET CONTROL CHARACTER
         STA     CNTRL    ; INITIALIZE KEYBOARD/DISPLAY BLANKING
         MVI     A,CSNIT  ; INITIAL VALUE OF COMMAND STATUS REGISTER
         OUT     CSR      ; INITIALIZE CSR
         STA     USCSR    ; INITIALIZE USER CSR VALUE
         JMP     CLDBK    ; BACK TO MAIN PROCEDURE
 ;
 ;
 ;
 ; FUNCTION: DISPC - DISPLAY PROGRAM COUNTER
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: UPDAD,UPDDT
 ; DESTROYS:
 ; DESCRIPTION: DISPC DISPLAYS THE USER PROGRAM COUNTER IN THE ADDRESS
 ;              FIELD OF THE DISPLAY, WITH A DOT AT THE RIGHT EDGE
 ;              OF THE FIELD. THE BYTE OF DATA ADDRESSED BY THE PROGRAM
 ;              COUNTER IS DISPLAYED IN THE DATA FIELD OF THE DISPLAY.
 ;
 DISPC:
         LHLD    PSAV     ; GET USER PROGRAM COUNTER
         SHLD    CURAD    ; MAKE IT THE CURRENT ADDRESS
         MOV     A,M      ; GET THE INSTRUCTION AT THAT ADDRESS
         STA     CURDT    ; MAKE IT THE CURRENT DATA
         MVI     B,DOT    ; ARG - DOT IN ADDRESS FIELD
         CALL    UPDAD    ; UPDATE ADDRESS FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN DATA FIELD
         CALL    UPDDT    ; UPDATE DATA FIELD OF DISPLAY
         RET
 ;
 ;
 ;
 ; FUNCTION: ERR - DISPLAY ERROR MESSAGE
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: OUTPT
 ; DESTROYS:
 ; DESCRIPTION: ERR IS JUMPED TO BY COMMAND ROUTINES WISHING TO
 ;              TERMINATE BECAUSE OF AN ERROR.
 ;              ERR OUTPUTS AN ERROR MESSAGE TO THE DISPLAY AND
 ;              BRANCHES TO THE COMMAND RECOGNIZER.
 ;
 ERR:
         XRA     A        ; ARG - USE ADDRESS FIELD
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         LXI     H,ERMSG  ; ARG - ADDRESS OF ERROR MESSAGE
         CALL    OUTPT    ; OUTPUT ERROR MESSAGE TO ADDRESS FIELD
         MVI     A,DTFLD  ; ARG - USE DATA FIELD
         MVI     B,NODOT  ; ARG - NO DOT IN DATA FIELD
         LXI     H,BLNKS  ; ARG - ADDRESS OF BLANKS FOR DISPLAY
         CALL    OUTPT    ; OUTPUT BLANKS TO DATA FIELD
         JMP     CMMND    ; GO GET A NEW COMMAND
 ;
 ;
 ;
 ; FUNCTION: GTHEX - GET HEX DIGITS
 ; INPUTS: B - DISPLAY FLAG - 0 MEANS USE ADDRESS FIELD OF DISPLAY
 ;                          - 1 MEANS USE DATA FIELD OF DISPLAY
 ; OUTPUTS: A - LAST CHARACTER READ FROM KEYBOARD
 ;          DE - HEX DIGITS FROM KEYBOARD EVALUATED MODULO 2**16
 ;          CARRY - SET IF AT LEAST ONE VALID HEX DIGIT WAS READ
 ;                - RESET OTHERWISE
 ; CALLS: RDKBD,INSDG,HXDSP,OUTPT
 ; DESTROYS:
 ; DESCRIPTION: GTHEX ACCEPTS A STRING OF HEX DIGITS FROM THE KEYBOARD,
 ;              DISPLAYS THEM AS THEY ARE RECEIVED, AND RETURNS THEIR
 ;              VALUE AS A 16 BIT INTEGER. IF MORE THAN 4 HEX DIGITS
 ;              ARE RECEIVED, ONLY THE LAST 4 ARE USED. IF THE DISPLAY
 ;              FLAG IS SET, THE LAST 2 HEX DIGITS ARE DISPLAYED IN THE
 ;              DATA FIELD OF THE DISPLAY. OTHERWISE, THE LAST 4 HEX
 ;              DIGITS ARE DISPLAYED IN THE ADDRESS FIELD OF THE
 ;              DISPLAY. IN EITHER CASE, A DOT WILL BE DISPLAYED AT THE
 ;              RIGHTMOST EDGE OF THE FIELD. A CHARACTER WHICH IS NOT
 ;              A HEX DIGIT TERMINATES THE STRING AND IS RETURNED AS
 ;              AN OUTPUT OF THE FUNCTION. IF THE TERMINATOR IS NOT
 ;              A PERIOD OR A COMMA THEN ANY HEX DIGITS WHICH MAY HAVE
 ;              BEEN RECEIVED ARE CONSIDERED TO BE INVALID. THE
 ;              FUNCTION RETURNS A FLAG INDICATING WHETHER OR NOT ANY
 ;              VALID HEX DIGITS WERE RECEIVED.
 ;
 GTHEX:
         MVI     C,0      ; RESET HEX DIGIT FLAG
         PUSH    B        ; SAVE DISPLAY AND HEX DIGIT FLAGS
         LXI     D,0      ; SET HEX VALUE TO ZERO
         PUSH    D        ; SAVE HEX VALUE
 GTH05:
         CALL    RDKBD    ; READ KEYBOARD
         CPI     10H      ; IS CHARACTER A HEX DIGIT?
         JNC     GTH20    ; NO - GO CHECK FOR TERMINATOR
                          ; YES - ARG - NEW HEX DIGIT IS IN A
         POP     D        ; ARG - RETRIEVE HEX VALUE
         CALL    INSDG    ; INSERT NEW DIGIT IN HEX VALUE
         POP     B        ; RETRIEVE DISPLAY FLAG
         MVI     C,1      ; SET HEX DIGIT FLAG
                          ; /(I.E. A HEX DIGIT HAS BEEN READ)
         PUSH    B        ; SAVE DISPLAY AND HEX DIGIT FLAGS
         PUSH    D        ; SAVE HEX VALUE
         MOV     A,B      ; TEST DISPLAY FLAG
         RRC              ; SHOULD ADDRESS FIELD OF DISPLAY BE USED ?
         JNC     GTH10    ; YES - USE HEX VALUE AS IS
                          ; NO - ONLY LOW ORDER BYTE OF HEX VALUE SHOULD
                          ; /BE USED FOR DATA FIELD OF DISPLAY
         MOV     D,E      ; PUT LOW ORDER BYTE OF HEX VALUE IN D
 GTH10:
                          ; ARG - HEX VALUE TO BE EXPANDED IS IN D & E
         CALL    HXDSP    ; EXPAND HEX VALUE FOR DISPLAY
                          ; ARG - ADDRESS OF EXPANDED HEX VALUE IN H & L
         MOV     A,B      ; ARG - PUT DISPLAY FLAG IN A
         MVI     B,DOT    ; ARG - DOT IN APPROPRIATE FIELD
         CALL    OUTPT    ; OUTPUT HEX VALUE TO DISPLAY
         JMP     GTH05    ; GO GET NEXT CHARACTER
 GTH20:                   ; LAST CHARACTER WAS NOT A HEX DIGIT
         POP     D        ; RETRIEVE HEX VALUE
         POP     B        ; RETRIEVE HEX DIGIT FLAG IN C
         CPI     COMMA    ; WAS LAST CHARACTER ',' ?
         JZ      GTH25    ; YES - READY TO RETURN
         CPI     PERIO    ; NO - WAS LAST CHARACTER '.' ?
         JZ      GTH25    ; YES - READY TO RETURN
                          ; NO - INVALID TERMINATOR - IGNORE ANY HEX DIGITS READ
         LXI     D,0      ; SET HEX VALUE TO ZERO
         JMP     RETF     ; RETURN FALSE
 GTH25:
         MOV     B,A      ; SAVE LAST CHARACTER
         MOV     A,C      ; SHIFT HEX DIGIT FLAG TO
         RRC              ; /CARRY BIT
         MOV     A,B      ; RESTORE LAST CHARACTER
         RET              ; RETURN
 ;
 ;
 ;
 ; FUNCTION: HXDSP - EXPAND HEX DIGITS FOR DISPLAY
 ; INPUTS: DE - 4 HEX DIGITS
 ; OUTPUTS: HL - ADDRESS OF OUTPUT BUFFER
 ; CALLS: NOTHING
 ; DESTROYS: A,H,L,F/P'S
 ; DESCRIPTION: HXDSP EXPANDS EACH INPUT BYTE TO 2 BYTES IN A FORM
 ;              SUITABLE FOR DISPLAY BY THE OUTPUT ROUTINES. EACH INPUT
 ;              BYTE IS DIVIDED INTO 2 HEX DIGITS. EACH HEX DIGIT IS
 ;              PLACED IN THE LOW ORDER 4 BITS OF A BYTE WHOSE HIGH
 ;              ORDER 4 BITS ARE SET TO ZERO. THE RESULTING BYTE IS
 ;              STORED IN THE OUTPUT BUFFER. THE FUNCTION RETURNS THE
 ;              ADDRESS OF THE OUTPUT BUFFER.
 ;
 HXDSP:
         MOV     A,D      ; GET FIRST DATA BYTE
         RRC              ; CONVERT 4 HIGH ORDER BITS
         RRC              ; /TO A SINGLE CHARACTER
         RRC
         RRC
         ANI     0FH
         LXI     H,OBUFF  ; GET ADDRESS OF OUTPUT BUFFER
         MOV     M,A      ; STORE CHARACTER IN OUTPUT BUFFER
         MOV     A,D      ; GET FIRST DATA BYTE AND CONVERT 4 LOW ORDER
         ANI     0FH      ; /BITS TO A SINGLE CHARACTER
         INX     H        ; NEXT BUFFER POSITION
         MOV     M,A      ; STORE CHARACTER IN BUFFER
         MOV     A,E      ; GET SECOND DATA BYTE
         RRC              ; CONVERT 4 HIGH ORDER BITS
         RRC              ; /TO A SINGLE CHARACTER
         RRC
         RRC
         ANI     0FH
         INX     H        ; NEXT BUFFER POSITION
         MOV     M,A      ; STORE CHARACTER IN BUFFER
         MOV     A,E      ; GET SECOND DATA BYTE AND CONVERT LOW ORDER
         ANI     0FH      ; /4 BITS TO A SINGLE CHARACTER
         INX     H        ; NEXT BUFFER POSITION
         MOV     M,A      ; STORE CHARACTER IN BUFFER
         LXI     H,OBUFF  ; RETURN ADDRESS OF OUTPUT BUFFER IN H & L
         RET
 ;
 ;
 ;
 ; FUNCTION: ININT - INPUT INTERRUPT PROCESSING
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: NOTHING
 ; DESTROYS: NOTHING
 ; DESCRIPTION: ININT IS ENTERED BY MEANS OF AN INTERRUPT VECTOR (IV2C)
 ;              WHEN THE READ KEYBOARD ROUTINE IS WAITING FOR A
 ;              CHARACTER AND THE USER HAS PRESSED A KEY ON THE
 ;              KEYBOARD (EXCEPT "RESET" OR "VECTORED INTERRUPT")
 ;              ININT STORES THE INPUT CHARACTER IN THE INPUT BUFFER AND
 ;              RETURNS CONTROL TO THE READ KEYBOARD ROUTINE.
 ;
 ININT:
         PUSH    H        ; SAVE H & L
         PUSH    PSW      ; SAVE F/F'S & REGISTER A
         LXI     H,CNTRL  ; ADDRESS FOR CONTROL CHARACTER OUTPUT
         MVI     M,READ   ; OUTPUT CONTROL CHARACTER FOR READING
                          ; /FROM KEYBOARD
         DCR     H        ; ADDRESS FOR CHARACTER INPUT
         MOV     A,M      ; READ A CHARACTER
         ANI     3FH      ; ZERO 2 HIGH ORDER BITS
         STA     IBUFF    ; STORE CHARACTER IN INPUT BUFFER
         POP     PSW      ; RESTORE F/F'S & REGISTER A
         POP     H        ; RESTORE H & L
         RET
 ;
 ;
 ;
 ; FUNCTION: INSDG - INSERT HEX DIGIT
 ; INPUTS: A - HEX DIGIT TO BE INSERTED
 ;         DE - HEX VALUE
 ; OUTPUTS: DE - HEX VALUE WITH DIGIT INSERTED
 ; CALLS: NOTHING
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: INSDG SHIFTS THE CONTENTS OF D & E LEFT 4 BITS
 ;              (1 HEX DIGIT) AND INSERTS THE HEX DIGIT IN A IN THE LOW
 ;              ORDER DIGIT POSITION OF THE RESULT. A IS ASSUMED TO
 ;              CONTAIN A SINGLE HEX DIGIT IN THE LOW ORDER 4 BITS AND
 ;              ZEROS IN THE HIGH ORDER 4 BITS.
 ;
 INSDG:
         XCHG             ; PUT D & E IN H & L
         DAD     H        ; SHIFT H & L LEFT 4 BITS
         DAD     H
         DAD     H
         DAD     H
         ADD     L        ; INSERT LOW ORDER DIGIT
         MOV     L,A
         XCHG             ; PUT H & L BACK IN D & E
         RET
 ;
 ;
 ;
 ; FUNCTION: NXTRG - ADVANCE REGISTER POINTER TO NEXT REGISTER
 ; INPUTS: NONE
 ; OUTPUTS: CARRY - 1 IF POINTER IS ADVANCED SUCCESSFULLY
 ;                - 0 OTHERWISE
 ; CALLS: NOTHING
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: IF THE REGISTER POINTER POINTS TO THE LAST REGISTER IN
 ;              THE EXAMINE REGISTER SEQUENCE, THE POINTER IS NOT
 ;              CHANGED AND THE FUNCTION RETURNS FALSE. IF THE REGISTER
 ;              POINTER DOES NOT POINT TO THE LAST REGISTER THEN THE
 ;              POINTER IS ADVANCED TO THE NEXT REGISTER IN THE SEQUENCE
 ;              AND THE FUNCTION RETURNS TRUE.
 ;
 NXTRG:
         LDA     RGPTR    ; GET REGISTER POINTER
         CPI     NUMRG-1  ; DOES POINTER POINT TO LAST REGISTER?
         JNC     RETF     ; YES - UNABLE TO ADVANCE POINTER - RETURN FALSE
         INR     A        ; NO - ADVANCE REGISTER POINTER
         STA     RGPTR    ; SAVE REGISTER POINTER
         JMP     RETT     ; RETURN TRUE
 ;
 ;
 ;
 ; FUNCTION: OUTPT - OUTPUT CHARACTERS TO DISPLAY
 ; INPUTS: A - DISPLAY FLAG - 0 = USE ADDRESS FIELD
 ;                            1 = USE DATA FIELD
 ;         B - DOT FLAG - 1 = OUTPUT DOT AT RIGHT EDGE OF FIELD
 ;                        0 = NO DOT
 ;         HL - ADDRESS OF CHARACTERS TO BE OUTPUT
 ; CALLS: NOTHING
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: OUTPT SENDS CHARACTERS TO THE DISPLAY. THE ADDRESS
 ;              OF THE CHARACTERS IS RECEIVED AS AN ARGUMENT. EITHER
 ;              2 CHARACTERS ARE SENT TO THE DATA FIELD, OR 4 CHARACTERS
 ;              ARE SENT TO THE ADDRESS FIELD, DEPENDING ON THE
 ;              DISPLAY FLAG ARGUMENT. THE DOT FLAG ARGUMENT DETERMINES
 ;              WHETHER OR NOT A DOT (DECIMAL POINT) WILL BE SENT
 ;              ALONG WITH THE LAST OUTPUT CHARACTER.
 ;
 OUTPT:
         RRC              ; USE DATA FIELD ?
         JC      OUT05    ; YES - GO SET UP TO USE DATA FIELD
         MVI     C,4      ; NO - COUNT FOR ADDRESS FIELD
         MVI     A,ADISP  ; CONTROL CHARACTER FOR OUTPUT TO ADDRESS
                          ; /FIELD OF DISPLAY
         JMP     OUT10
 OUT05:
         MVI     C,2      ; COUNT FOR DATA FIELD
         MVI     A,DDISP  ; CONTROL CHARACTER FOR OUTPUT TO DATA FIELD
                          ; /OF DISPLAY
 OUT10:
         STA     CNTRL
 OUT15:
         MOV     A,M      ; GET OUTPUT CHARACTER
         XCHG             ; SAVE OUTPUT CHARACTER ADDRESS IN D & E
         LXI     H,DSPTB  ; GET DISPLAY FORMAT TABLE ADDRESS
         ADD     L        ; USE OUTPUT CHARACTER AS A POINTER TO
         MOV     L,A      ; /DISPLAY FORMAT TABLE
         MOV     A,M      ; GET DISPLAY FORMAT CHARACTER FROM TABLE
         MOV     H,C      ; TEST COUNTER WITHOUT CHANGING IT
         DCR     H        ; IS THIS THE LAST CHARACTER ?
         JNZ     OUT20    ; NO - GO OUTPUT CHARACTER AS IS
         DCR     B        ; YES - IS DOT FLAG SET ?
         JNZ     OUT20    ; NO - GO OUTPUT CHARACTER AS IS
         ORI     DTMSK    ; YES - OR IN MASK TO DISPLAY DOT WITH
                          ; /LAST CHARACTER
 OUT20:
         CMA              ; COMPLEMENT OUTPUT CHARACTER
         STA     DSPLY    ; SEND CHARACTER TO DISPLAY
         XCHG             ; RETRIEVE OUTPUT CHARACTER ADDRESS
         INX     H        ; NEXT OUTPUT CHARACTER
         DCR     C        ; ANY MORE OUTPUT CHARACTERS ?
         JNZ     OUT15    ; YES - GO PROCESS ANOTHER CHARACTER
         RET              ; NO - RETURN
 ;
 ;
 ;
 ; FUNCTION: RDKBD - READ KEYBOARD
 ; INPUTS: NONE
 ; OUTPUTS: A - CHARACTER READ FROM KEYBOARD
 ; CALLS: NOTHING
 ; DESTROYS: A,H,L,F/F'S
 ; DESCRIPTION: RDKBD DETERMINES WHETHER OR NOT THERE IS A CHARACTER IN
 ;              THE INPUT BUFFER. IF NOT, THE FUNCTION ENABLES
 ;              INTERRUPTS AND LOOPS UNTIL THE INPUT INTERRUPT
 ;              ROUTINE STORES A CHARACTER IN THE BUFFER. WHEN
 ;              THE BUFFER CONTAINS A CHARACTER, THE FUNCTION FLAGS
 ;              THE BUFFER AS EMPTY AND RETURNS THE CHARACTER
 ;              AS OUTPUT.
 ;
 RDKBD:
         LXI     H,IBUFF  ; GET INPUT BUFFER ADDRESS
         MOV     A,M      ; GET BUFFER CONTENTS
                          ; HIGH ORDER BIT = 1 MEANS BUFFER IS EMPTY
         ORA     A        ; IS A CHARACTER AVAILABLE ?
         JP      RDK10    ; YES - EXIT FROM LOOP
         EI               ; NO - READY FOR CHARACTER FROM KEYBOARD
         JMP     RDKBD
 RDK10:
         MVI     M,EMPTY  ; SET BUFFER EMPTY FLAG
         DI               ; RETURN WITH INTERRUPTS DISABLED
         RET
 ;
 ;
 ;
 ; FUNCTION: RETF - RETURN FALSE
 ; INPUTS: NONE
 ; OUTPUTS: CARRY = 0 (FALSE)
 ; CALLS: NOTHING
 ; DESTROYS: CARRY
 ; DESCRIPTION: RETF IS JUMPED TO BY FUNCTIONS WISHING TO RETURN FALSE.
 ;              RETF RESETS CARRY TO 0 AND RETURNS TO THE CALLER OF
 ;              THE ROUTINE INVOKING RETF.
 ;
 RETF:
         STC              ; SET CARRY TRUE
         CMC              ; COMPLEMENT CARRY TO MAKE IT FALSE
         RET
 ;
 ;
 ;
 ; FUNCTION: RETT - RETURN TRUE
 ; INPUTS: NONE
 ; OUTPUTS: CARRY = 1 (TRUE)
 ; CALLS: NOTHING
 ; DESTROYS: CARRY
 ; DESCRIPTION: RETT IS JUMPED TO BY ROUTINES WISHING TO RETURN TRUE.
 ;              RETT SETS CARRY TO 1 AND RETURNS TO THE CALLER OF
 ;              THE ROUTINE INVOKING RETT.
 ;
 RETT:
         STC              ; SET CARRY TRUE
         RET
 ;
 ;
 ;
 ; FUNCTION: RGLOC - GET REGISTER SAVE LOCATION
 ; INPUTS: NONE
 ; OUTPUTS: HL - REGISTER SAVE LOCATION
 ; CALLS: NOTHING
 ; DESTROYS: B,C,H,L,F/F'S
 ; DESCRIPTION: RGLOC RETURNS THE SAVE LOCATION OF THE REGISTER
 ;              INDICATED BY THE CURRENT REGISTER POINTER VALUE.
 ;
 RGLOC:
         LHLD    RGPTR    ; GET REGISTER POINTER
         MVI     H,0      ; /IN H & L
         LXI     B,RGTBL  ; GET REGISTER SAVE LOCATION TABLE ADDRESS
         DAD     B        ; POINTER INDEXES TABLE
         MOV     L,M      ; GET LOW ORDER BYTE OF REGISTER SAVE LOC.
         MVI     H,RAMST SHR 8 ; GET HIGH ORDER BYTE OF
                          ; /REGISTER SAVE LOCATION
         RET
 ;
 ;
 ;
 ; FUNCTION: RGNAM - DISPLAY REGISTER NAME
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: OUTPT
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: RGNAM DISPLAYS, IN THE ADDRESS FIELD OF THE DISPLAY,
 ;              THE REGISTER NAME CORRESPONDING TO THE CURRENT
 ;              REGISTER POINTER VALUE.
 ;
 RGNAM:
         LHLD    RGPTR    ; GET REGISTER POINTER
         MVI     H,0
         DAD     H        ; MULTIPLY POINTER VALUE BY 4
         DAD     H        ; /(REGISTER NAME TABLE HAS 4 BYTE ENTRIES)
         LXI     B,NMTBL  ; GET ADDRESS OF START OF REGISTER NAME TABLE
         DAD     B        ; ARG - ADD TABLE ADDRESS TO POINTER - RESULT IS
                          ; /ADDRESS OF APPROPRIATE REGISTER NAME IN H & L
         XRA     A        ; ARG - USE ADDRESS FIELD OF DISPLAY
         MVI     B,NODOT  ; ARG - NO DOT IN ADDRESS FIELD
         CALL    OUTPT    ; OUTPUT REGISTER NAME TO ADDRESS FIELD
         RET
 ;
 ;
 ;
 ; FUNCTION: RSTOR - RESTOR USER REGISTERS
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: NOTHING
 ; DESTROYS:
 ; DESCRIPTION: RSTOR RESTORES ALL CPU REGISTERS, FLIP/FLOPS,
 ;              INTERRUPT STATUS, INTERRUPT MASK, STACK POINTER
 ;              AND PROGRAM COUNTER FROM THEIR RESPECTIVE
 ;              SAVE LOCATIONS IN MEMORY. BY RESTORING THE PROGRAM
 ;              COUNTER, THE ROUTINE EFFECTIVELY TRANSFERS CONTROL TO
 ;              THE ADDRESS IN THE PROGRAM COUNTER SAVE LOCATION.
 ;
 ;              THE TIMING OF THIS ROUTINE IS CRITICAL TO THE
 ;              CORRECT OPERATION OF THE SINGLE STEP ROUTINE.
 ;              IF ANY MODIFICATION CHANGES THE NUMBER OF CPU
 ;              STATES NEEDED TO EXECUTE THIS ROUTINE THEN THE
 ;              TIMER VALUE MUST BE ADJUSTED BY THE SAME NUMBER.
 ;
 ;              THIS IS ALSO THE ENTRY POINT FOR THE TTY MONITOR
 ;              TO RESTORE REGISTERS.
 ;
 RSTOR:
         LDA     ISAV     ; GET USER INTERRUPT MASK
         ORI     18H      ; ENABLE SETTING OF INTERRUPT MASK AND
                          ; /RESET RST7.5 FLIP FLOP
         SIM              ; RESTORE USER INTERRUPT MASK
                          ; RESTORE USER INTERRUPT STATUS
         LDA     ISAV     ; GET USER INTERRUPT MASK
         ANI     08H      ; SHOULD USER INTERRUPTS BE ENABLED ?
         JZ      RSR05    ; NO - LEAVE INTERRUPTS DISABLED
         EI               ; YES - ENABLE INTERRUPTS FOR USER PROGRAM
         JMP     RSR10
 RSR05:
         STC              ; DUMMY INSTRUCTIONS - WHEN SINGLE STEP ROUTINE
         JNC     RSR10    ; /IS BEING USED, THE TIMER IS RUNNING AND
                          ; /EXECUTE TIME FOR THIS ROUTINE MUST NOT
                          ; /VARY.
 RSR10:
         LXI     H,MNSTK  ; SET MONITOR STACK POINTER TO START OF STACK
         SPHL             ; /WHICH IS ALSO END OF REGISTER SAVE AREA
         POP     D        ; RESTORE REGISTERS
         POP     B
         POP     PSW
         LHLD    SSAV     ; RESTORE USER STACK POINTER
         SPHL
         LHLD    PSAV
         PUSH    H        ; PUT USER PROGRAM COUNTER ON STACK
         LHLD    LSAV     ; RESTORE H & L REGISTERS
         RET              ; JUMP TO USER PROGRAM COUNTER
 ;
 ;
 ;
 ; FUNCTION: SETRG - SET REGISTER POINTER
 ; INPUTS: NONE
 ; OUTPUTS: CARRY - SET IF CHARACTER FROM KEYBOARD IS A REGISTER DESIGNATOR
 ; RESET OTHERWISE
 ; CALLS: RDKBD
 ; DESTROYS: A,B,C,H,L,F/F'S
 ; DESCRIPTION: SETRG READS A CHARACTER FROM THE KEYBOARD. IF THE
 ;              CHARACTER IS A REGISTER DESIGNATOR, IT IS CONVERTED TO
 ;              THE CORRESPONDING REGISTER POINTER VALUE, THE POINTER IS
 ;              SAVED, AND THE FUNCTION RETURNS 'TRUE'. OTHERWISE, THE
 ;              FUNCTION RETURNS FALSE'
 ;
 SETRG:
         CALL    RDKBD    ; READ FROM KEYBOARD
         CPI     10H      ; IS CHARACTER A DIGIT?
         JNC     RETF     ; NO - RETURN FALSE - CHARACTER IS NOT A
                          ; /REGISTER DESIGNATOR
         SUI     3        ; YES - TRY TO CONVERT REGISTER DESIGNATOR TO
                          ; / INDEX INTO REGISTER POINTER TABLE
                          ; WAS CONVERSION SUCCESSFUL?
         JC      RETF     ; NO - RETURN FALSE
         MOV     C,A      ; INDEX TO B & C
         MVI     B,0      ;
         LXI     H,RGPTB  ; GET ADDRESS OF REGISTER POINTER TABLE
         DAD     B        ; INDEX POINTS INTO TABLE
         MOV     A,M      ; GET REGISTER POINTER FROM TABLE
         STA     RGPTR    ; SAVE REGISTER POINTER
         JMP     RETT     ; RETURN TRUE
 ;
 ;
 ;
 ; FUNCTION: UPDAD - UPDATE ADDRESS FIELD OF DISPLAY
 ; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT AT RIGHT EDGE OF FIELD
 ; 0 MEANS NO DOT
 ; OUTPUTS: NONE
 ; CALLS: HXDSP,OUTPT
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: UPDAD UPDATES THE ADDRESS FIELD OF THE DISPLAY USING
 ;              THE CURRENT ADDRESS.
 ;
 UPDAD:
         LHLD    CURAD    ; GET CURRENT ADDRESS
         XCHG             ; ARG - PUT CURRENT ADDRESS IN D & E
         CALL    HXDSP    ; EXPAND CURRENT ADDRESS FOR DISPLAY
                          ; ARG - ADDRESS OF EXPANDED ADDRESS IS IN H & L
         XRA     A        ; ARG - USE ADDRESS FIELD OF DISPLAY
                          ; ARG - DOT FLAG IS IN B
         CALL    OUTPT    ; OUTPUT CURRENT ADDRESS TO ADDRESS FIELD
         RET
 ;
 ;
 ;
 ; FUNCTION: UPDOT - UPDATE DATA FIELD OF DISPLAY
 ; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT AT RIGHT EDGE OF FIELD
 ; 0 MEANS NO DOT
 ; OUTPUTS: NONE
 ; CALLS: HXDSP,OUTDT
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: UPODT UPDATES THE DATA FIELD OF THE DISPLAY USING
 ;              THE CURRENT DATA BYTE.
 ;
 UPDDT:
         LDA     CURDT    ; GET CURRENT DATA
         MOV     D,A      ; ARG - PUT CURRENT DATA IN D
         CALL    HXDSP    ; EXPAND CURRENT DATA FOR DISPLAY
                          ; ARG - ADDRESS OF EXPANDED DATA IS IN H & L
         MVI     A,DTFLD  ; ARG - USE DATA FIELD OF DISPLAY
                          ; ARG - DOT FLAG IS IN B
         CALL    OUTPT    ; OUTPUT CURRENT DATA TO DATA FIELD
         RET
 ;
 ;
 ;
 ; MONITOR TABLES
 ;
 ;
 ;
 ; COMMAND TABLE
 ; COMMAND CHARACTERS AS RECEIVED FROM KEYBOARD
 CMDTB:
         DB      12H      ; GO COMMAND
         DB      13H      ; SUBSTITUTE MEMORY COMMAND
         DB      14H      ; EXAMINE REGISTERS COMMAND
         DB      15H      ; SINGLE STEP COMMAND
 NUMC    EQU      $-CMDTB ; NUMBER OF COMMANDS
 ;
 ;
 ;
 ; COMMAND ROUTINE ADDRESS TABLE
 ; (MUST BE IN REVERSE ORDER OF COMMAND TABLE)
 CMDAD:
         DW      SSTEP    ; ADDRESS OF SINGLE STEP ROUTINE
         DW      EXAM     ; ADDRESS OF EXAMINE REGISTERS ROUTINE
         DW      SUBST    ; ADDRESS OF SUBSTITUTE MEMORY ROUTINE
         DW      GOCMD    ; ADDRESS OF GO ROUTINE
 ;
 ;
 ;
 DSPTB:           ; TABLE FOR TRANSLATING CHARACTERS FOR OUTPUT
 ;
 ; DISPLAY
 ; FORMAT CHARACTER
 ;
 ;
 ZERO    EQU      $-DSPTB
         DB      0F3H     ; 0
         DB      60H      ; 1
         DB      0B5H     ; 2
         DB      0F4H     ; 3
         DB      66H      ; 4
 FIVE    EQU      $-DSPTB
 LETRS   EQU      $-DSPTB
         DB      0D6H     ; 5 AND S
         DB      0D7H     ; 6
         DB      70H      ; 7
 EIGHT   EQU      $-DSPTB
         DB      0F7H     ; 8
         DB      76H      ; 9
 LETRA   EQU      $-DSPTB
         DB      77H      ; A
 LETRB   EQU      $-DSPTB
         DB      0C7H     ; B (LOWER CASE)
 LETRC   EQU      $-DSPTB
         DB      93H      ; C
 LETRD   EQU      $-DSPTB
         DB      0E5H     ; D (LOWER CASE)
 LETRE   EQU      $-DSPTB
         DB      97H      ; E
 LETRF   EQU      $-DSPTB
         DB      17H      ; F
 LETRH   EQU      $-DSPTB
         DB      67H      ; H
 LETRL   EQU      $-DSPTB
         DB      83H      ; L
 LETRP   EQU      $-DSPTB
         DB      37H      ; P
 LETRI   EQU      $-DSPTB
         DB      60H      ; I
 LETRR   EQU      $-DSPTB
         DB      05H      ; R (LOWER CASE)
 BLANK   EQU      $-DSPTB
         DB      00H      ; BLANK
 ;
 ;
 ;
 ; MESSAGES FOR OUTPUT TO DISPLAY
 ;
 BLNKS:  DB       BLANK,BLANK,BLANK,BLANK ; FOR ADDRESS OR DATA FIELD



 ERMSG:  DB       BLANK,LETRE,LETRR,LETRR ; ERROR MESSAGE FOR ADDR. FIELD



 EXMSG:  DB       LETRE,BLANK,BLANK,BLANK ; EXECUTION MESSAGE


                                          ; /FOR ADDRESS FIELD
 SGNAD:  DB       BLANK,BLANK,EIGHT,ZERO  ; SIGN ON MESSAGE (ADDR. FIELD)



 SGNDT:  DB       EIGHT,FIVE              ; SIGN ON MESSAGE (DATA FIELD)
 ;
 ;
 ;
 RGPTB:           ; REGISTER POINTER TABLE
 ; THE ENTRIES IN THIS TABLE ARE IN THE SAME ORDER
 ; AS THE REGISTER DESIGNATOR KEYS ON THE KEYBOARD.
 ; EACH ENTRY CONTAINS THE REGISTER POINTER VALUE WHICH
 ; CORRESPONDS TO THE REGISTER DESIGNATOR. REGISTER
 ; POINTER VALUES ARE USED TO POINT INTO THE REGISTER
 ; NAME TABLE (NMTBL) AND REGISTER SAVE LOCATION
 ; TABLE (RGTBL)
 ;
         DB      6        ; INTERRUPT MASK
         DB      9        ; SPH
         DB      10       ; SPL
         DB      11       ; PCH
         DB      12       ; PCL
         DB      7        ; H
         DB      8        ; L
         DB      0        ; A
         DB      1        ; B
         DB      2        ; C
         DB      3        ; D
         DB      4        ; E
         DB      5        ; FLAGS
 ;
 ;
 ;
 NMTBL:           ; REGISTER NAME TABLE
                  ; NAMES OF REGISTERS IN DISPLAY FORMAT
         DB      BLANK,BLANK,BLANK,LETRA ; A REGISTER



         DB      BLANK,BLANK,BLANK,LETRB ; B REGISTER



         DB      BLANK,BLANK,BLANK,LETRC ; C REGISTER



         DB      BLANK,BLANK,BLANK,LETRD ; D REGISTER



         DB      BLANK,BLANK,BLANK,LETRE ; E REGISTER



         DB      BLANK,BLANK,BLANK,LETRF ; FLAGS



         DB      BLANK,BLANK,BLANK,LETRI ; INTERRUPT MASK



         DB      BLANK,BLANK,BLANK,LETRH ; H REGISTER



         DB      BLANK,BLANK,BLANK,LETRL ; L REGISTER



         DB      BLANK,LETRS,LETRP,LETRH ; STACK POINTER HIGH ORDER BYTE



         DB      BLANK,LETRS,LETRP,LETRL ; STACK POINTER LOW ORDER BYTE



         DB      BLANK,LETRP,LETRC,LETRH ; PROGRAM COUNTER HIGH BYTE



         DB      BLANK,LETRP,LETRC,LETRL ; PROGRAM COUNTER LOW BYTE


 ;
 ;
 ;
 ; REGISTER SAVE LOCATION TABLE
 ; ADDRESSES OF SAVE LOCATIONS OF REGISTERS IN THE ORDER IN WHICH
 ; THE REGISTERS ARE DISPLAYED BY THE EXAMINE COMMAND
 ;
 RGTBL:
         DB      ASAV     AND 0FFH ; A REGISTER
         DB      BSAV     AND 0FFH ; B REGISTER
         DB      CSAV     AND 0FFH ; C REGISTER
         DB      DSAV     AND 0FFH ; D REGISTER
         DB      ESAV     AND 0FFH ; E REGISTER
         DB      FSAV     AND 0FFH ; FLAGS
         DB      ISAV     AND 0FFH ; INTERRUPT MASK
         DB      HSAV     AND 0FFH ; H REGISTER
         DB      LSAV     AND 0FFH ; L REGISTER
         DB      SPHSV    AND 0FFH ; STACK POINTER HIGH ORDER BYTE
         DB      SPLSV    AND 0FFH ; STACK POINTER LOW ORDER BYTE
         DB      PCHSV    AND 0FFH ; PROGRAM COUNTER HIGH ORDER BYTE
         DB      PCLSV    AND 0FFH ; PROGRAM COUNTER LOW ORDER BYTE
 NUMRG   EQU      $-RGTBL          ; NUMBER OF ENTRIES IN
                                   ; /REGISTER SAVE LOCATION TABLE
 ;
 ;
 ;
 ;
 ; SDK-85 TTY MONITOR
 ;
 ;
 ;
 ;
 ;
 ; ABSTRACT
 ;
 ;
 ; THIS PROGRAM WAS ADAPTED, WITH FEW CHANGES, FROM THE SDK-80 MONITOR.
 ; THIS PROGRAM RUNS ON THE 8085 BOARD AND IS DESIGNED TO PROVIDE
 ; THE USER WITH A MINIMAL MONITOR. BY USING THIS PROGRAM,
 ; THE USER CAN EXAMINE AND CHANGE MEMORY OR CPU REGISTERS, LOAD
 ; A PROGRAM (IN ABSOLUTE HEX) INTO RAM, AND EXECUTE INSTRUCTIONS
 ; ALREADY IN MEMORY. THE MONITOR ALSO PROVIDES THE USER WITH
 ; ROUTINES FOR PERFORMING CONSOLE I/O.
 ;
 ;
 ; PROGRAM ORGANIZATION
 ;
 ;
 ; THE LISTING IS ORGANIZED IN THE FOLLOWING WAY. FIRST THE COMMAND
 ; RECOGNIZER, WHICH IS THE HIGHEST LEVEL ROUTINE IN THE PROGRAM.
 ; NEXT THE ROUTINES TO IMPLEMENT THE VARIOUS COMMANDS. FINALLY,
 ; THE UTILITY ROUTINES WHICH ACTUALLY DO THE DIRTY WORK. WITHIN
 ; EACH SECTION, THE ROUTINES ARE ORGANIZED IN ALPHABETICAL
 ; ORDER, BY ENTRY POINT OF THE ROUTINE.
 ;
 ; MACROS USED IN THE TTY MONITOR ARE DEFINED IN THE KEYBOARD MONITOR.
 ;
 ; LIST OF FUNCTIONS
 ; --
 ;
 ; GETCM
 ;
 ;
 ; DCMD
 ; GCMD
 ; ICMD
 ; MCMD
 ; SCMD
 ; XCMD
 ;
 ;
 ; CI
 ; CNVBN
 ; CO
 ; CROUT
 ; DELAY
 ; ECHO
 ; ERROR
 ; FRET
 ; GETCH
 ; GETHX
 ; GETNM
 ; HILO
 ; NMOUT
 ; PRVAL
 ; REGDS
 ; RGADR
 ; SRET
 ; STHF0
 ; STHLF
 ; VALDG
 ; VALDL
 ;
 ;
 ;
 ;
 ;
 ;
 ; MONITOR EQUATES
 ;
 ;
 ;
 ;
 ;
 BRCHR   EQU      1BH     ; CODE FOR BREAK CHARACTER (ESCAPE)
 BRTAB   EQU      07FAH   ; LOCATION OF START OF BRANCH TABLE IN ROM
 CR      EQU      0DH     ; CODE FOR CARRIAGE RETURN
 ESC     EQU      1BH     ; CODE FOR ESCAPE CHARACTER
 HCHAR   EQU      0FH     ; MASK TO SELECT LOWER HEX CHAR FROM BYTE
 INVRT   EQU      0FFH    ; MASK TO INVERT HALF BYTE FLAG
 LF      EQU      0AH     ; CODE FOR LINE FEED
 LOWER   EQU      0       ; DENOTES LOWER HALF OF BYTE IN ICMD
 ; LSGNON  EQU      ---     ; LENGTH OF SIGNON MESSAGE - DEFINED LATER
 ; MNSTK   EQU      ---     ; START OF MONITOR STACK - DEFINED IN
                          ; /KEYBOARD MONITOR
 ; NCMDS   EQU      ---     ; NUMBER OF VALID COMMANDS - DEFINED LATER
 NEWLN   EQU      0FH     ; MASK FOR CHECKING MEMORY ADDR DISPLAY
 PRTY0   EQU      7FH     ; MASK TO CLEAR PARITY BIT FROM CONSOLE CHAR
 ; RAMST   EQU      ---     ; START ADDRESS OF RAM - DEFINED IN
                          ; KEYBOARD MONITOR
 ; RTABS   EQU      ---     ; SIZE OF ENTRY IN RTAB TABLE
 SSTRT   EQU      80H     ; SHIFTED START BIT
 STOPB   EQU      40H     ; STOP BIT
 STRT    EQU      0C0H    ; UNSHIFTED START BIT
 TERM    EQU      1BH     ; CODE FOR ICMD TERMINATING CHARACTER (ESCAPE)
 UPPER   EQU      0FFH    ; DENOTES UPPER HALF OF BYTE IN ICMD
 ;
 ; DELAY VALUES IF NO WAIT STATE
 ;
         IF      1-WAITS
 IBTIM   EQU      1164    ; INTER-BIT TIME DELAY
 OBTIM   EQU      1164    ; OUTPUT INTER-BIT TIME DELAY
 TIM4    EQU      4656    ; 4 BIT TIME DELAY
 WAIT    EQU      582     ; DELAY UNTIL READY TO SAMPLE BITS
         ENDIF
 ;
 ; DELAY VALUES IF ONE WAIT STATE
 ;
         IF      WAITS
 IBTIM   EQU      930     ; INTER-BIT DELAY
 OBTIM   EQU      930     ; OUTPUT INTER-BIT TIME DELAY
 TIM4    EQU      3720    ; 4 BIT TIME DELAY
 WAIT    EQU      465     ; DELAY UNTIL READY TO SAMPLE BITS
         ENDIF
 ;
 ;
 ;
 ;
 ;
 ; RESTART ENTRY POINT
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ; PRINT SIGNON MESSAGE
 ;
 ;
 ;
 ;
 ;
 GO:
         LXI     H,SGNON  ; GET ADDRESS OF SIGNON MESSAGE
         MVI     B,LSGNON ; COUNTER FOR CHARACTERS IN MESSAGE
 MSGL:
         MOV     C,M      ; FETCH NEXT CHAR TO C REG
         CALL    CO       ; SEND IT TO THE CONSOLE
         INX     H        ; POINT TO NEXT CHARACTER
         DCR     B        ; DECREMENT BYTE COUNTER
         JNZ     MSGL     ; RETURN FOR NEXT CHARACTER
 ;
 ;
 ;
 ;
 ;
 ; COMMAND RECOGNIZING ROUTINE
 ;
 ;
 ;
 ;
 ; FUNCTION: GETCM
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: GETCH,ECHO,ERROR
 ; DESTROYS: A,B,C,H,L,F/F'S
 ; DESCRIPTION: GETCM RECEIVES AN INPUT CHARACTER FROM THE USER
 ;              AND ATTEMPTS TO LOCATE THIS CHARACTER IN ITS COMMAND
 ;              CHARACTER TABLE. IF SUCCESSFUL, THE ROUTINE
 ;              CORRESPONDING TO THIS CHARACTER IS SELECTED FROM
 ;              A TABLE OF COMMAND ROUTINE ADDRESSES, AND CONTROL
 ;              IS TRANSFERRED TO THIS ROUTINE. IF THE CHARACTER
 ;              DOES NOT MATCH ANY ENTRIES, CONTROL IS PASSED TO
 ;              THE ERROR HANDLER.
 ;
 GETCM:
         LXI     H,MNSTK  ; ALWAYS WANT TO RESET STACK PTR TO MONITOR
         SPHL             ; /STARTING VALUE SO ROUTINES NEEDN'T CLEAN UP
         MVI     C,'.'    ; PROMPT CHARACTER TO C
         CALL    ECHO     ; SEND PROMPT CHARACTER TO USER TERMINAL
         JMP     GTC03    ; WANT TO LEAVE ROOM FOR RST BRANCH
 GTC03:
         CALL    GETCH    ; GET COMMAND CHARACTER TO A
         CALL    ECHO     ; ECHO CHARACTER TO USER
         MOV     A,C      ; PUT COMMAND CHARACTER INTO ACCUMULATOR
         LXI     B,NCMDS  ; C CONTAINS LOOP AND INDEX COUNT
         LXI     H,CTAB   ; HL POINTS INTO COMMAND TABLE
 GTC05:
         CMP     M        ; COMPARE TABLE ENTRY AND CHARACTER
         JZ      GTC10    ; BRANCH IF EQUAL - COMMAND RECOGNIZED
         INX     H        ; ELSE, INCREMENT TABLE POINTER
         DCR     C        ; DECREMENT LOOP COUNT
         JNZ     GTC05    ; BRANCH IF NOT AT TABLE END
         JMP     ERROR    ; ELSE, COMMAND CHARACTER IS ILLEGAL
 GTC10:
         LXI     H,CADR   ; IF GOOD COMMAND, LOAD ADDRESS OF TABLE
                          ; /OF COMMAND ROUTINE ADDRESSES
         DAD     B        ; ADD WHAT IS LEFT OF LOOP COUNT
         DAD     B        ; ADD AGAIN - EACH ENTRY IN CADR IS 2 BYTES LONG
         MOV     A,M      ; GET LSP OF ADDRESS OF TABLE ENTRY TO A
         INX     H        ; POINT TO NEXT BYTE IN TABLE
         MOV     H,M      ; GET MSP OF ADDRESS OF TABLE ENTRY TO H
         MOV     L,A      ; PUT LSP OF ADDRESS OF TABLE ENTRY INTO L
         PCHL             ; NEXT INSTRUCTION COMES FROM COMMAND ROUTINE
 ;
 ;
 ;
 ;
 ;
 ; COMMAND IMPLEMENTING ROUTINES
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: DCMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: ECHO,NMOUT,HILO,GETCM,CROUT, GETNM
 ; DESTROYS:
 ; DESCRIPTION: DCMD IMPLEMENTS THE DISPLAY MEMORY (D) COMMAND
 ;
 DCMD:
         MVI     C,2      ; GET 2 NUMBERS FROM INPUT STREAM
         CALL    GETNM
         POP     D        ; ENDING ADDRESS TO DE
         POP     H        ; STARTING ADDRESS TO HL
 DCM05:
         CALL    CROUT    ; ECHO CARRIAGE RETURN/LINE FEED
         MOV     A,H      ; DISPLAY ADDRESS OF FIRST LOCATION IN LINE
         CALL    NMOUT
         MOV     A,L      ; ADDRESS IS 2 BYTES LONG
         CALL    NMOUT
 DCM10:
         MVI     C,' '
         CALL    ECHO     ; USE BLANK AS SEPARATOR
         MOV     A,M      ; GET CONTENTS OF NEXT MEMORY LOCATION
         CALL    NMOUT    ; DISPLAY CONTENTS
         CALL    HILO     ; SEE IF ADDRESS OF DISPLAYED LOCATION IS
                          ; /GREATER THAN OR EQUAL TO ENDING ADDRESS
         FALSE   DCM15    ; IF NOT, MORE TO DISPLAY
         JNC     DCM15
         CALL    CROUT    ; CARRIAGE RETURN/LINE FEED TO END LINE
         JMP     GETCM    ; ALL DONE
 DCM15:
         INX     H        ; IF MORE TO GO, POINT TO NEXT LOC TO DISPLAY
         MOV     A,L      ; GET LOW ORDER BITS OF NEW ADDRESS
         ANI     NEWLN    ; SEE IF LAST HEX DIGIT OF ADDRESS DENOTES
                          ; /START OF NEW LINE
         JNZ     DCM10    ; NO - NOT AT END OF LINE
         JMP     DCM05    ; YES - START NEW LINE WITH ADDRESS
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: GCMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: ERROR,GETHX,RSTTF
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: GCMD IMPLEMENTS THE BEGIN EXECUTION (G) COMMAND.
 ;
 GCMD:
         CALL    GETHX    ; GET ADDRESS (IF PRESENT) FROM INPUT STREAM
         FALSE   GCM05    ; BRANCH IF NO NUMBER PRESENT
         JNC     GCM05
         MOV     A,D      ; ELSE, GET TERMINATOR
         CPI     CR       ; SEE IF CARRIAGE RETURN
         JNZ     ERROR    ; ERROR IF NOT PROPERLY TERMINATED
         LXI     H,PSAV   ; WANT NUMBER TO REPLACE SAVE PGM COUNTER
         MOV     M,C
         INX     H
         MOV     M,B
         JMP     GCM10
 GCM05:
         MOV     A,D      ; IF NO STARTING ADDRESS, MAKE SURE THAT
         CPI     CR       ; /CARRIAGE RETURN TERMINATED COMMAND
         JNZ     ERROR    ; ERROR IF NOT
 GCM10:
         JMP     RSTOR    ; RESTORE REGISTERS AND BEGIN EXECUTION
                          ; (RSTOR IS IN KEYBOARD MONITOR)
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: ICMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: ERROR,ECHO,GETCH,VALDL,VALDG,CNVBN,STHLF,GETNM,CROUT
 ; DESTROYS:
 ; DESCRIPTION: ICMD IMPLEMENTS THE INSERT CODE INTO MEMORY (I) COMMAND.
 ;
 ICMD:
         MVI     C,1
         CALL    GETNM    ; GET SINGLE NUMBER FROM INPUT STREAM
         MVI     A,UPPER
         STA     TEMP     ; TEMP WILL HOLD THE UPPER/LOWER HALF BYTE FLAG
         POP     D        ; ADDRESS OF START TO DE
 ICM05:
         CALL    GETCH    ; GET A CHARACTER FROM INPUT STREAM
         MOV     C,A
         CALL    ECHO     ; ECHO IT
         MOV     A,C      ; PUT CHARACTER BACK INTO A
         CPI     TERM     ; SEE IF CHARACTER IS A TERMINATING CHARACTER
         JZ      ICM25    ; IF SO, ALL DONE ENTERING CHARACTERS
         CALL    VALDL    ; ELSE, SEE IF VALID DELIMITER
         TRUE    ICM05    ; IF SO SIMPLY IGNORE THIS CHARACTER
         JC      ICM05
         CALL    VALDG    ; ELSE, CHECK TO SEE IF VALID HEX DIGIT
         FALSE   ICM20    ; IF NOT, BRANCH TO HANDLE ERROR CONDITION
         JNC     ICM20
         CALL    CNVBN    ; CONVERT DIGIT TO BINARY
         MOV     C,A      ; MOVE RESULT TO C
         CALL    STHLF    ; STORE IN APPROPRIATE HALF WORD
         LDA     TEMP     ; GET HALF BYTE FLAG
         ORA     A        ; SET F/F'S
         JNZ     ICM10    ; BRANCH IF FLAG SET FOR UPPER
         INX     D        ; IF LOWER, INC ADDRESS OF BYTE TO STORE IN
 ICM10:
         XRI     INVRT    ; TOGGLE STATE OF FLAG
         STA     TEMP     ; PUT NEW VALUE OF FLAG BACK
         JMP     ICM05    ; PROCESS NEXT DIGIT
 ICM20:
         CALL    STHF0    ; ILLEGAL CHARACTER
         JMP     ERROR    ; MAKE SURE ENTIRE BYTE FILLED THEN ERROR
 ICM25:
         CALL    STHF0    ; HERE FOR ESCAPE CHARACTER - INPUT IS DONE
         CALL    CROUT    ; ADD CARRIAGE RETURN
         JMP     GETCM
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: MCMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: GETCM,HILO,GETNM
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: MCMD IMPLEMENTS THE MOVE DATA IN MEMORY (M) COMMAND.
 ;
 MCMD:
         MVI     C,3
         CALL    GETNM    ; GET 3 NUMBERS FROM INPUT STREAM
         POP     B        ; DESTINATION ADDRESS TO BC
         POP     H        ; ENDING ADDRESS TO HL
         POP     D        ; STARTING ADDRESS TO DE
 MCM05:
         PUSH    H        ; SAVE ENDING ADDRESS
         MOV     H,D
         MOV     L,E      ; SOURCE ADDRESS TO HL
         MOV     A,M      ; GET SOURCE BYTE
         MOV     H,B
         MOV     L,C      ; DESTINATION ADDRESS TO HL
         MOV     M,A      ; MOVE BYTE TO DESTINATION
         INX     B        ; INCREMENT DESTINATION ADDRESS
         MOV     A,B
         ORA     C        ; TEST FOR DESTINATION ADDRESS OVERFLOW
         JZ      GETCM    ; IF SO, CAN TERMINATE COMMAND
         INX     D        ; INCREMENT SOURCE ADDRESS
         POP     H        ; ELSE, GET BACK ENDING ADDRESS
         CALL    HILO     ; SEE IF ENDING ADDR>=SOURCE ADDR
         FALSE   GETCM    ; IF NOT, COMMAND IS DONE
         JNC     GETCM
         JMP     MCM05    ; MOVE ANOTHER BYTE
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: SCMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: GETHX,GETCM,NMOUT,ECHO
 ; DESTROYS:
 ; DESCRIPTION: SCMD IMPLEMENTS THE SUBSTITUTE INTO MEMORY (S) COMMAND.
 ;
 SCMD:
         CALL    GETHX    ; GET A NUMBER, IF PRESENT, FROM INPUT
         PUSH    B
         POP     H        ; GET NUMBER TO HL - DENOTES MEMORY LOCATION
 SCM05:
         MOV     A,D      ; GET TERMINATOR
         CPI     ' '      ; SEE IF SPACE
         JZ      SCM10    ; YES - CONTINUE PROCESSING
         CPI     ','      ; ELSE, SEE IF COMMA
         JNZ     GETCM    ; NO - TERMINATE COMMAND
 SCM10:
         MOV     A,M      ; GET CONTENTS OF SPECIFIED LOCATION TO A
         CALL    NMOUT    ; DISPLAY CONTENTS ON CONSOLE
         MVI     C,'-'
         CALL    ECHO     ; USE DASH FOR SEPARATOR
         CALL    GETHX    ; GET NEW VALUE FOR MEMORY LOCATION, IF ANY
         FALSE   SCM15    ; IF NO VALUE PRESENT, BRANCH
         JNC     SCM15
         MOV     M,C      ; ELSE, STORE LOWER 8 BITS OF NUMBER ENTERED
 SCM15:
         INX     H        ; INCREMENT ADDRESS OF MEMORY LOCATION TO VIEW
         JMP     SCM05
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: XCMD
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: GETCH,ECHO,REGDS,GETCM,ERROR,RGADR,NMOUT,CROUT,GETHX
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: XCMD IMPLEMENTS THE REGISTER EXAMINE AND CHANGE (X)
 ;              COMMAND.
 ;
 XCMD:
         CALL    GETCH    ; GET REGISTER IDENTIFIER
         MOV     C,A
         CALL    ECHO     ; ECHO IT
         MOV     A,C
         CPI     CR
         JNZ     XCM05    ; BRANCH IF NOT CARRIAGE RETURN
         CALL    REGDS    ; ELSE, DISPLAY REGISTER CONTENTS
         JMP     GETCM    ; THEN TERMINATE COMMAND
 XCM05:
         MOV     C,A      ; GET REGISTER IDENTIFIER TO C
         CALL    RGADR    ; CONVERT IDENTIFIER INTO RTAB TABLE ADDR
         PUSH    B
         POP     H        ; PUT POINTER TO REGISTER ENTRY INTO HL
         MVI     C,' '
         CALL    ECHO     ; ECHO SPACE TO USER
         MOV     A,C
         STA     TEMP     ; PUT SPACE INTO TEMP AS DELIMITER
 XCM10:
         LDA     TEMP     ; GET TERMINATOR
         CPI     ' '      ; SEE IF A BLANK
         JZ      XCM15    ; YES - GO CHECK POINTER INTO TABLE
         CPI     ','      ; NO - SEE IF COMMA
         JNZ     GETCM    ; NO - MUST BE CARRIAGE RETURN TO END COMMAND
 XCM15:
         MOV     A,M
         ORA     A        ; SET F/F'S
         JNZ     XCM18    ; BRANCH IF NOT AT END OF TABLE
         CALL    CROUT    ; ELSE, OUTPUT CARRIAGE RETURN LINE FEED
         JMP     GETCM    ; AND EXIT
 XCM18:
         PUSH    H        ; PUT POINTER ON STACK
         MOV     E,M
         MVI     D,RAMST SHR 8 ; ADDRESS OF SAVE LOCATION FROM TABLE
         INX     H
         MOV     B,M      ; FETCH LENGTH FLAG FROM TABLE
         PUSH    D        ; SAVE ADDRESS OF SAVE LOCATION
         PUSH    D
         POP     H        ; MOVE ADDRESS TO HL
         PUSH    B        ; SAVE LENGTH FLAG
         MOV     A,M      ; GET 8 BITS OF REGISTER FROM SAVE LOCATION
         CALL    NMOUT    ; DISPLAY IT
         POP     PSW      ; GET BACK LENGTH FLAG
         PUSH    PSW      ; SAVE IT AGAIN
         ORA     A        ; SET F/F'S
         JZ      XCM20    ; IF 8 BIT REGISTER, NOTHING MORE TO DISPLAY
         DCX     H        ; ELSE, FOR 16 BIT REGISTER, GET LOWER 8 BITS
         MOV     A,M
         CALL    NMOUT    ; DISPLAY THEM
 XCM20:
         MVI     C,'-'
         CALL    ECHO     ; USE DASH AS SEPARATOR
         CALL    GETHX    ; SEE IF THERE IS A VALUE TO PUT INTO REGISTER
         FALSE   XCM30    ; NO - GO CHECK FOR NEXT REGISTER
         JNC     XCM30
         MOV     A,D
         STA     TEMP     ; ELSE, SAVE THE TERMINATOR FOR NOW
         POP     PSW      ; GET BACK LENGTH FLAG
         POP     H        ; PUT ADDRESS OF SAVE LOCATION INTO HL
         ORA     A        ; SET F/F'S
         JZ      XCM25    ; IF 8 BIT REGISTER, BRANCH
         MOV     M,B      ; SAVE UPPER 8 BITS
         DCX     H        ; POINT TO SAVE LOCATION FOR LOWER 8 BITS
 XCM25:
         MOV     M,C      ; STORE ALL OF 8 BIT OR LOWER 1/2 OF 16 BIT REG
 XCM27:
         LXI     D,RTABS  ; SIZE OF ENTRY IN RTAB TABLE
         POP     H        ; POINTER INTO REGISTER TABLE RTAB
         DAD     D        ; ADD ENTRY SIZE TO POINTER
         JMP     XCM10    ; DO NEXT REGISTER
 XCM30:
         MOV     A,D      ; GET TERMINATOR
         STA     TEMP     ; SAVE IN MEMORY
         POP     D        ; CLEAR STACK OF LENGTH FLAG AND ADDRESS
         POP     D        ; /OF SAVE LOCATION
         JMP     XCM27    ; GO INCREMENT REGISTER TABLE POINTER
 ;
 ;
 ;
 ;
 ;
 ; UTILITY ROUTINES
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: CI
 ; INPUTS: NONE
 ; OUTPUTS: A - CHARACTER FROM TTY
 ; CALLS: DELAY
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: CI WAITS UNTIL A CHARACTER HAS BEEN ENTERED AT THE
 ;              TTY AND THEN RETURNS THE CHARACTER, VIA THE A
 ;              REGISTER, TO THE CALLING ROUTINE. THIS ROUTINE
 ;              IS CALLED BY THE USER VIA A JUMP TABLE IN RAM.
 ;
 CI:
         DI
         PUSH    D        ; SAVE DE
 CI05:
         RIM              ; GET INPUT BIT
         RAL              ; INTO CARRY WITH IT
         JC      CI05     ; BRANCH IF NO START BIT
         LXI     D,WAIT   ; WAIT UNTIL MIDDLE OF BIT
         CALL    DELAY
         PUSH    B        ; SAVE BC
         LXI     B,8      ; B<--0, C<--# BITS TO RECEIVE
 CI10:
         LXI     D,IBTIM
         CALL    DELAY    ; WAIT UNTIL MIDDLE OF NEXT BIT
         RIM              ; GET THE BIT
         RAL              ; INTO CARRY
         MOV     A,B      ; GET PARTIAL RESULT
         RAR              ; SHIFT IN NEXT DATA BIT
         MOV     B,A      ; REPLACE RESULT
         DCR     C        ; DEC COUNT OF BITS TO GO
         JNZ     CI10     ; BRANCH IF MORE LEFT
         LXI     D,IBTIM  ; ELSE, WANT TO WAIT OUT STOP BIT
         CALL    DELAY
         MOV     A,B      ; GET RESULT
         POP     B
         POP     D        ; RESTORE SAVED REGISTERS
         EI
         RET              ; THAT'S IT
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: CNVBN
 ; INPUTS: C - ASCII CHARACTER '0'-'9' OR 'A'-'F'
 ; OUTPUTS: A - 0 TO F HEX
 ; CALLS: NOTHING
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: CNVBN CONVERTS THE ASCII REPRESENTATION OF A HEX
 ;              CNVBN INTO ITS CORRESPONDING BINARY VALUE. CNVBN
 ;              DOES NOT CHECK THE VALIDITY OF ITS INPUT.
 ;
 CNVBN:
         MOV     A,C
         SUI     '0'      ; SUBTRACT CODE FOR '0' FROM ARGUMENT
         CPI     10       ; WANT TO TEST FOR RESULT OF 0 TO 9
         RM               ; IF SO, THEN ALL DONE
         SUI     7        ; ELSE, RESULT BETWEEN 17 AND 23 DECIMAL
         RET              ; SO RETURN AFTER SUBTRACTING BIAS OF 7
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: CO
 ; INPUTS: C - CHARACTER TO OUTPUT TO TTY
 ; OUTPUTS: C - CHARACTER OUTPUT TO TTY
 ; CALLS: DELAY
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: CO SENDS ITS INPUT ARGUMENT TO THE TTY.
 ;
 CO:
         DI
         PUSH    B        ; SAVE BC
         PUSH    D        ; SAVE DE
         MVI     A,STRT   ; START BIT MASK
         MVI     B,7      ; B WILL COUNT BITS TO SEND
 CO05:
         SIM              ; SEND A BIT
         LXI     D,OBTIM  ; WAIT FOR TTY TO HANDLE IT
         CALL    DELAY
         MOV     A,C      ; PICK UP BITS LEFT TO SEND
         RAR              ; LOW ORDER BIT TO CARRY
         MOV     C,A      ; PUT REST BACK
         MVI     A,SSTRT  ; SHIFTED ENABLE BIT
         RAR              ; SHIFT IN DATA BIT
         XRI     80H      ; COMPLEMENT DATA BIT
         DCR     B        ; DEC COUNT
         JP      CO05     ; SEND IF MORE BITS NEED TO BE SENT
         MVI     A,STOPB  ; ELSE, SEND STOP BITS
         SIM
         LXI     D,TIM4   ; WAIT 4 BIT TIME (FAKE PARITY + 3 STOP BITS)
         CALL    DELAY
         POP     D
         POP     B        ; RESTORE SAVED REGISTERS
         EI
         RET              ; ALL DONE
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION CROUT
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: ECHO
 ; DESTROYS: A,B,C,E/P'S
 ; DESCRIPTION: CROUT SENDS A CARRIAGE RETURN (AND HENCE A LINE
 ;              FEED) TO THE CONSOLE.
 ;
 CROUT:
         MVI     C,CR
         CALL    ECHO
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: DELAY
 ; INPUTS: DE - 16 BIT INTEGER DENOTING NUMBER OF TIMES TO LOOP
 ; OUTPUTS: NONE
 ; CALLS: NOTHING
 ; DESTROYS: A,D,E,F/F'S
 ; DESCRIPTION: DELAY DOES NOT RETURN TO CALLER UNTIL INPUT ARGUMENT
 ;              IS COUNTED DOWN TO 0.
 ;
 DELAY:
         DCX     D        ; DECREMENT INPUT ARGUMENT
         MOV     A,D
         ORA     E
         JNZ     DELAY    ; IF ARGUMENT NOT 0, KEEP GOING
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: ECHO
 ; INPUTS: C - CHARACTER TO ECHO TO TERMINAL
 ; OUTPUTS: C - CHARACTER ECHOED TO TERMINAL
 ; CALLS: CO
 ; DESTROYS: A,B,F/F'S
 ; DESCRIPTION: ECHO TAKES A SINGLE CHARACTER AS INPUT AND, VIA
 ;              THE MONITOR, SENDS THAT CHARACTER TO THE USER
 ;              TERMINAL. A CARRIAGE RETURN IS ECHOED AS A CARRIAGE
 ;              RETURN LINE FEED, AND AN ESCAPE CHARACTER IS ECHOED AS $.
 ;
 ECHO:
         MOV     B,C      ; SAVE ARGUMENT
         MVI     A,ESC
         CMP     B        ; SEE IF ECHOING AN ESCAPE CHARACTER
         JNZ     ECH05    ; NO - BRANCH
         MVI     C,'$'    ; YES - ECHO AS $
 ECH05:
         CALL    CO       ; DO OUTPUT THROUGH MONITOR
         MVI     A,CR
         CMP     B        ; SEE IF CHARACTER ECHOED WAS A CARRIAGE RETURN
         JNZ     ECH10    ; NO - NO NEED TO TAKE SPECIAL ACTION
         MVI     C,LF     ; YES - WANT TO ECHO LINE FEED, TOO
         CALL    CO
 ECH10:
         MOV     C,B      ; RESTORE ARGUMENT
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: ERROR
 ; INPUTS NONE
 ; OUTPUTS: NONE
 ; CALLS: ECHO,CROUT,GETCM
 ; DESTROYS: A,B,C,F/F'S
 ; DESCRIPTION: ERROR PRINTS THE ERROR CHARACTER (CURRENTLY AN ASTERISK)
 ;              ON THE CONSOLE, FOLLOWED BY A CARRIAGE RETURN-LINE FEED,
 ;              AND THEN RETURNS CONTROL TO THE COMMAND RECOGNIZER.
 ;
 ERROR:
         MVI     C,'*'
         CALL    ECHO     ; SEND * TO CONSOLE
         CALL    CROUT    ; SKIP TO BEGINNING OF NEXT LINE
         JMP     GETCM    ; TRY AGAIN FOR ANOTHER COMMAND
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: FRET
 ; OUTPUTS: CARRY - ALWAYS 0
 ; CALLS: NOTHING
 ; DESTROYS: CARRY
 ; DESCRIPTION: FRET IS JUMPED TO BY ANY ROUTINE THAT WISHES TO
 ;              INDICATE FAILURE ON RETURN. FRET SETS THE CARRY
 ;              FALSE, DENOTING FAILURE, AND THEN RETURNS TO THE
 ;              CALLER OF THE ROUTINE INVOKING FRET.
 ;
 FRET:
         STC              ; FIRST SET CARRY TRUE
         CMC              ; THEN COMPLEMENT IT TO MAKE IT FALSE
         RET              ; RETURN APPROPRIATELY
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: GETCH
 ; INPUTS: NONE
 ; OUTPUTS: C - NEXT CHARACTER IN INPUT STREAM
 ; CALLS: CI
 ; DESTROYS: A,C,F/F'S
 ; DESCRIPTION: GETCH RETURNS THE NEXT CHARACTER IN THE INPUT STREAM
 ;              TO THE CALLING PROGRAM.
 ;
 GETCH:
         CALL    CI       ; GET CHARACTER FROM TERMINAL
         ANI     PRTY0    ; TURN OFF PARITY BIT IN CASE SET BY CONSOLE
         MOV     C,A      ; PUT VALUE IN C REGISTER FOR RETURN
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: GETHX
 ; INPUTS: NONE
 ; OUTPUTS: BC - 16 BIT INTEGER
 ;          D - CHARACTER WHICH TERMINATED THE INTEGER
 ;          CARRY - 1 IF FIRST CHARACTER NOT DELIMITER
 ;                - 0 IF FIRST CHARACTER IS DELIMITER
 ; CALLS: GETCH,ECHO,VALDL,VALDG,CNVBN,ERROR
 ; DESTROYS: A,B,C,D,E,F/F'S
 ; DESCRIPTION: GETHX ACCEPTS A STRING OF HEX DIGITS FROM THE INPUT
 ;              STREAM AND RETURNS THEIR VALUE AS A 16 BIT BINARY
 ;              INTEGER. IF MORE THAN 4 HEX DIGITS ARE ENTERED,
 ;              ONLY THE LAST 4 ARE USED. THE NUMBER TERMINATES WHEN
 ;              A VALID DELIMITER IS ENCOUNTERED. THE DELIMITER IS
 ;              ALSO RETURNED AS AN OUTPUT OF THE FUNCTION. ILLEGAL
 ;              CHARACTERS (NOT HEX DIGITS OR DELIMITERS) CAUSE AN
 ;              ERROR INDICATION. IF THE FIRST (VALID) CHARACTER
 ;              ENCOUNTERED IN THE INPUT STREAM IS NOT A DELIMITER,
 ;              GETHX WILL RETURN WITH THE CARRY BIT SET TO 1;
 ;              OTHERWISE, THE CARRY BIT IS SET TO 0 AND THE CONTENTS
 ;              OF BC ARE UNDEFINED.
 ;
 GETHX:
         PUSH    H        ; SAVE HL
         LXI     H,0      ; INITIALIZE RESULT
         MVI     E,0      ; INITIALIZE DIGIT FLAG TO FALSE
 GHX05:
         CALL    GETCH    ; GET A CHARACTER
         MOV     C,A
         CALL    ECHO     ; ECHO THE CHARACTER
         CALL    VALDL    ; SEE IF DELIMITER
         FALSE   GHX10    ; NO - BRANCH
         JNC     GHX10
         MOV     D,C      ; YES - ALL DONE, BUT WANT TO RETURN DELIMITER
         PUSH    H
         POP     B        ; MOVE RESULT TO BC
         POP     H        ; RESTORE HL
         MOV     A,E      ; GET FLAG
         ORA     A        ; SET F/F'S
         JNZ     SRET     ; IF FLAG NON-0, A NUMBER HAS BEEN FOUND
         JZ      FRET     ; ELSE, DELIMITER WAS FIRST CHARACTER
 GHX10:
         CALL    VALDG    ; IF NOT DELIMITER, SEE IF DIGIT
         FALSE   ERROR    ; ERROR IF NOT A VALID DIGIT, EITHER
         JNC     ERROR
         CALL    CNVBN    ; CONVERT DIGIT TO ITS BINARY VALUE
         MVI     E,0FFH   ; SET DIGIT FLAG NON-0
         DAD     H        ; *2
         DAD     H        ; *4
         DAD     H        ; *8
         DAD     H        ; *16
         MVI     B,0      ; CLEAR UPPER 8 BITS OF BC PAIR
         MOV     C,A      ; BINARY VALUE OF CHARACTER INTO C
         DAD     B        ; ADD THIS VALUE TO PARTIAL RESULT
         JMP     GHX05    ; GET NEXT CHARACTER
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: GETNM
 ; INPUTS: C - COUNT OF NUMBERS TO FIND IN INPUT STREAM
 ; OUTPUTS: TOP OF STACK - NUMBERS FOUND IN REVERSE ORDER (LAST ON TOP
 ; OF STACK)
 ; CALLS: GETHX,HILO,ERROR
 ; DESTROYS:
 ; DESCRIPTION: GETNM FINDS A SPECIFIED COUNT OF NUMBERS, BETWEEN 1
 ;              AND 3, INCLUSIVE, IN THE INPUT
 ;              STREAM AND RETURNS THEIR VALUES ON THE STACK. IF 2
 ;              OR MORE NUMBERS ARE REQUESTED, THEN THE FIRST MUST BE
 ;              LESS THAN OR EQUAL TO THE SECOND, OR THE FIRST AND
 ;              SECOND NUMBERS WILL BE SET EQUAL. THE LAST NUMBER
 ;              REQUESTED MUST BE TERMINATED BY A CARRIAGE RETURN
 ;              OR AN ERROR INDICATION WILL RESULT.
 ;
 GETNM:
         MVI     L,3      ; PUT MAXIMUM ARGUMENT COUNT INTO L
         MOV     A,C      ; GET THE ACTUAL ARGUMENT COUNT
         ANI     3        ; FORCE TO MAXIMUM OF 3
         RZ               ; IF 0, DON'T BOTHER TO DO ANYTHIING
         MOV     H,A      ; ELSE, PUT ACTUAL COUNT INTO H
 GNM05:
         CALL    GETHX    ; GET A NUMBER FROM INPUT STREAM
         FALSE   ERROR    ; ERROR IF NOT THERE - TOO FEW NUMBERS
         JNC     ERROR
         PUSH    B        ; ELSE, SAVE NUMBER ON STACK
         DCR     L        ; DECREMENT MAXIMUM ARGUMENT COUNT
         DCR     H        ; DECREMENT ACTUAL ARGUMENT COUNT
         JZ      GNM10    ; BRANCH IF NO MORE NUMBERS WANTED
         MOV     A,D      ; ELSE, GET NUMBER TERMINATOR TO A
         CPI     CR       ; SEE IF CARRIAGE RETURN
         JZ      ERROR    ; ERROR IF SO - TOO FEW NUMBERS
         JMP     GNM05    ; ELSE, PROCESS NEXT NUMBER
 GNM10:
         MOV     A,D      ; WHEN COUNT 0, CHECK LAST TERMINATOR
         CPI     CR
         JNZ     ERROR    ; ERROR IF NOT CARRIAGE RETURN
         LXI     B,0FFFFH ; HL GETS LARGEST NUMBER
         MOV     A,L      ; GET WHAT'S LEFT OF MAXIMUM ARG COUNT
         ORA     A        ; CHECK FOR 0
         JZ      GNM20    ; IF YES, 3 NUMBERS WERE INPUT
 GNM15:
         PUSH    B        ; IF NOT, FILL REMAINING ARGUMENTS WITH 0FFFFH
         DCR     L
         JNZ     GNM15
 GNM20:
         POP     B        ; GET THE 3 ARGUMENTS OUT
         POP     D
         POP     H
         CALL    HILO     ; SEE IF FIRST >= SECOND
         FALSE   GNM25    ; NO - BRANCH
         JNC     GNM25
         MOV     D,H
         MOV     E,L      ; YES - MAKE SECOND EQUAL TO THE FIRST
 GNM25:
         XTHL             ; PUT FIRST ON STACK - GET RETURN ADDR
         PUSH    D        ; PUT SECOND ON STACK
         PUSH    B        ; PUT THIRD ON STACK
         PUSH    H        ; PUT RETURN ADDRESS ON STACK
 GNM30:
         DCR     A        ; DECREMENT RESIDUAL COUNT
         RM               ; IF NEGATIVE, PROPER RESULTS ON STACK
         POP     H        ; ELSE, GET RETURN ADDR
         XTHL             ; REPLACE TOP RESULT WITH RETURN ADDR
         JMP     GNM30    ; TRY AGAIN
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: HILO
 ; INPUTS: DE - 16 BIT INTEGER
 ;         HL - 16 BIT INTEGER
 ; OUTPUTS: CARRY - 0 IF HL<DE
 ;                - 1 IF HL>=DE
 ; CALLS: NOTHING
 ; DESTROYS: F/F'S
 ; DESCRIPTION: HILO COMPARES THE 2 16 BIT INTEGERS IN HL AND DE. THE
 ;              INTEGERS ARE TREATED AS UNSIGNED NUMBERS. THE CARRY
 ;              BIT IS SET ACCORDING TO THE RESULT OF THE COMPARISON.
 ;
 HILO:
         PUSH    B        ; SAVE BC
         MOV     B,A      ; SAVE A IN B REGISTER
         PUSH    H        ; SAVE HL PAIR
         MOV     A,D      ; CHECK FOR DE = 0000H
         ORA     E
         JZ      HIL05    ; WE'RE AUTOMATICALLY DONE IF IT IS
         INX     H        ; INCREMENT HL BY 1
         MOV     A,H      ; WANT TO TEST FOR 0 RESULT AFTER
         ORA     L        ; /INCREMENTING
         JZ      HIL05    ; IF SO, HL MUST HAVE CONTAINED OFFFFH
         POP     H        ; IF NOT, RESTORE ORIGINAL HL
         PUSH    D        ; SAVE DE
         MVI     A,0FFH   ; WANT TO TAKE 2'S COMPLEMENT OF DE CONTENTS
         XRA     D
         MOV     D,A
         MVI     A,0FFH
         XRA     E
         MOV     E,A
         INX     D        ; 2'S COMPLEMENT OF DE TO DE
         MOV     A,L
         ADD     E        ; ADD HL AND DE
         MOV     A,H
         ADC     D        ; THIS OPERATION SETS CARRY PROPERLY
         POP     D        ; RESTORE ORIGINAL DE CONTENTS
         MOV     A,B      ; RESTORE ORIGINAL CONTENTS OF A
         POP     B        ; RESTORE ORIGINAL CONTENTS OF BC
         RET              ; RETURN WITH CARRY SET AS REQUIRED
 HIL05:
         POP     H        ; IF HL CONTAINS OFFFFH, THEN CARRY CAN
         MOV     A,B      ; /ONLY BE SET TO 1
         POP     B        ; RESTORE ORIGINAL CONTENTS OF REGISTERS
         JMP     SRET     ; SET CARRY AND RETURN
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: NMOUT
 ; INPUTS: A - 8 BIT INTEGER
 ; OUTPUTS: NONE
 ; CALLS: ECHO,PRVAL
 ; DESTROYS: A,B,C,F/F'S
 ; DESCRIPTION: NNMOUT CONVERTS THE 8 BIT, UNSIGNED INTEGER IN THE
 ;              A REGISTER INTO 2 ASCII CHARACTERS. THE ASCII CHARACTERS
 ;              ARE THE ONES REPRESENTING THE 8 BITS. THESE TWO
 ;              CHARACTERS ARE SENT TO THE CONSOLE AT THE CURRENT PRINT
 ;              POSITION OF THE CONSOLE.
 ;
 NMOUT:
         PUSH    H        ; SAVE HL - DESTROYED BY PRVAL
         PUSH    PSW      ; SAVE ARGUMENT
         RRC
         RRC
         RRC
         RRC              ; GET UPPER 4 BITS TO LOW 4 BIT POSITIONS
         ANI     HCHAR    ; MASK OUT UPPER 4 BITS - WANT 1 HEX CHAR
         MOV     C,A
         CALL    PRVAL    ; CONVERT LOWER 4 BITS TO ASCII
         CALL    ECHO     ; SEND TO TERMINAL
         POP     PSW      ; GET BACK ARGUMENT
         ANI     HCHAR    ; MASK OUT UPPER 4 BITS - WANT 1 HEX CHAR
         MOV     C,A
         CALL    PRVAL
         CALL    ECHO
         POP     H        ; RESTORE SAVED VALUE OF HL
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: PRVAL
 ; INPUTS: C - INTEGER, RANGE 0 TO F
 ; OUTPUTS: C - ASCII CHARACTER
 ; CALLS: NOTHING
 ; DESTROYS: B,C,H,L,P/F'S
 ; DESCRIPTION: PRVAL CONVERTS A NUMBER IN THE RANGE 0 TO F HEX TO
 ;              THE CORRESPONDING ASCII CHARACTER, 0-9,A-F. PRVAL
 ;              DOES NOT CHECK THE VALIDITY OF ITS INPUT ARGUMENT.
 ;
 PRVAL:
         LXI     H,DIGTB  ; ADDRESS OF TABLE
         MVI     B,0      ; CLEAR HIGH ORDER BITS OF BC
         DAD     B        ; ADD DIGIT VALUE TO HL ADDRESS
         MOV     C,M      ; FETCH CHARACTER FROM MEMORY
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: REGDS
 ; INPUTS: NONE
 ; OUTPUTS: NONE
 ; CALLS: ECHO,NMOUT,ERROR,CROUT
 ; DESTROYS:
 ; DESCRIPTION: REGDS DISPLAYS THE CONTENTS OF THE REGISTER SAVE
 ;              LOCATIONS, IN FORMATTED FORM, ON THE CONSOLE. THE
 ;              DISPLAY IIS DRIVEN FROM A TABLE, RTAB, WHICH CONTAINS
 ;              THE REGISTER'S PRINT SYMBOL, SAVE LOCATION ADDRESS,
 ;              AND LENGTH (8 OR 16 BITS)
 ;
 REGDS:
         LXI     H,RTAB   ; LOAD HL WITH ADDRESS OF START OF TABLE
 REG05:
         MOV     C,M      ; GET PRINT SYMBOL OF REGISTER
         MOV     A,C
         ORA     A        ; TEST FOR 0 - END OF TABLE
         JNZ     REG10    ; IF NOT END, BRANCH
         CALL    CROUT    ; ELSE, CARRIAGE RETURN/LINE FEED TO END
         RET              ; /DISPLAY
 REG10:
         CALL    ECHO     ; ECHO CHARACTER
         MVI     C,'='
         CALL    ECHO     ; OUTPUT EQUALS SIGN, I.E. A=
         INX     H        ; POINT TO START OF SAVE LOCATION ADDRESS
         MOV     E,M      ; GET LSP OF SAVE LOCATION ADDRESS TO E
         MVI     D,RAMST SHR 8 ; PUT MSP OF SAVE LOC ADDRESS INTO D
         INX     H        ; POINT TO LENGTH FLAG
         LDAX    D        ; GET CONTENTS OF SAVE ADDRESS
         CALL    NMOUT    ; DISPLAY ON CONSOLE
         MOV     A,M      ; GET LENGTH FLAG
         ORA     A        ; SET SIGN F/F
         JZ      REG15    ; IF 0, REGISTER IS 8 BITS
         DCX     D        ; ELSE, 16 BIT REGISTER SO MORE TO DISPLAY
         LDAX    D        ; GET LOWER 8 BITS
         CALL    NMOUT    ; DISPLAY THEM
 REG15:
         MVI     C,' '
         CALL    ECHO
         INX     H        ; POINT TO START OF NEXT TABLE ENTRY
         JMP     REG05    ; DO NEXT REGISTER
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: RGADR
 ; INPUTS: C - CHARACTER DENOTING REGISTER
 ; OUTPUTS: BC - ADDRESS OF ENTRY IN RTAB CORRESPONDING TO REGISTER
 ; CALLS: ERROR
 ; DESTROYS: A,B,C,D,E,H,L,F/F'S
 ; DESCRIPTION: RGADR TAKES A SINGLE CHARACTER AS INPUT. THIS CHARACTER
 ;              DENOTES A REGISTER. RGADR SEARCHES THE TABLE RTAB
 ;              FOR A MATCH ON THE INPUT ARGUMENT. IF ONE OCCURS,
 ;              RGADR RETURNS THE ADDRESS OF THE ADDRESS OF THE
 ;              SAVE LOCATION CORRESPONDING TO THE REGISTER. THIS
 ;              ADDRESS POINTS INTO RTAB. IF NO MATCH OCCURS, THEN
 ;              THE REGISTER IDENTIFIER IS ILLEGAL AND CONTROL IS
 ;              PASSED TO THE ERROR ROUTINE.
 ;
 RGADR:
         LXI     H,RTAB   ; HL GETS ADDRESS OF TABLE START
         LXI     D,RTABS  ; DE GET SIZE OF A TABLE ENTRY
 RGA05:
         MOV     A,M      ; GET REGISTER IDENTIFIER
         ORA     A        ; CHECK FOR TABLE END (IDENTIFIER IS 0)
         JZ      ERROR    ; IF AT END OF TABLE, ARGUMENT IS ILLEGAL
         CMP     C        ; ELSE, COMPARE TABLE ENTRY AND ARGUMENT
         JZ      RGA10    ; IF EQUAL, WE'VE FOUND WHAT WE'RE LOOKING FOR
         DAD     D        ; ELSE, INCREMENT TABLE POINTER TO NEXT ENTRY
         JMP     RGA05    ; TRY AGAIN
 RGA10:
         INX     H        ; IF A MATCH, INCREMENT TABLE POINTER TO
         MOV     B,H      ; /SAVE LOCATION ADDRESS
         MOV     C,L      ; RETURN THIS VALUE
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: SRET
 ; INPUTS: NONE
 ; OUTPUTS: CARRY = 1
 ; CALLS: NOTHING
 ; DESTROYS: CARRY
 ; DESCRIPTION: SRET IS JUMPED TO BY ROUTINES WISHING TO RETURN SUCCESS.
 ;              SRET SETS THE CARRY TRUE AND THEN RETURNS TO THE
 ;              CALLER OF THE ROUTINE INVOKING SRET.
 ;
 SRET:
         STC              ; SET CARRY TRUE
         RET              ; RETURN APPROPRIATELY
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: STHF0
 ; INPUTS: DE - 16 BIT ADDRESS OF BYTE TO BE STORED INTO
 ; OUTPUTS: NONE
 ; CALLS: STHLF
 ; DESTROYS: A,B,C,H,L,F/F'S
 ; DESCRIPTION: STHF0 CHECKS THE HALF BYTE FLAG IN TEMP TO SEE IF
 ;              IT IS SET TO LOWER. IF SO, STHF0 STORES A 0 TO
 ;              PAD OUT THE LOWER HALF OF THE ADDRESSED BYTE;
 ;              OTHERWISE, THE ROUTINE TAKES NO ACTION.
 ;
 STHF0:
         LDA     TEMP     ; GET HALF BYTE FLAG
         ORA     A        ; SET F/F'S
         RNZ              ; IF SET TO OPPER, DON'T DO ANYTHING
         MVI     C,0      ; ELSE, WANT TO STORE THE VALUE 0
         CALL    STHLF    ; DO IT
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: STHLF
 ; INPUTS: C - 4 BIT VALUE TO BE STORED IN HALF BYTE
 ;         DE - 16 BIT ADDRESS OF BYTE TO BE STORED INTO
 ; OUTPUTS: NONE
 ; CALLS: NOTHING
 ; DESTROYS: A,B,C,H,L,F/F'S
 ; DESCRIPTION: STHLF TAKES THE 4 BIT VALUE IN C AND STORES IT IN
 ;              HALF OF THE BYTE ADDRESSED BY REGISTERS DE. THE
 ;              HALF BYTE USED (EITHER UPPER OR LOWER) IS DENOTED
 ;              BY THE VALUE OF THE FLAG IN TEMP. STHLF ASSUMES
 ;              THAT THIS FLAG HAS BEEN PREVIOUSLY SET
 ;              (NOMINALLY BY ICMD)
 ;
 STHLF:
         PUSH    D
         POP     H        ; MOVE ADDRESS OF BYTE INTO HL
         MOV     A,C      ; GET VALUE
         ANI     0FH      ; FORCE TO 4 BIT LENGTH
         MOV     C,A      ; PUT VALUE BACK
         LDA     TEMP     ; GET HALF BYTE FLAG
         ORA     A        ; CHECK FOR LOWER HALF
         JNZ     STH05    ; BRANCH IF NOT
         MOV     A,M      ; ELSE, GET BYTE
         ANI     0F0H     ; CLEAR LOWER 4 BITS
         ORA     C        ; OR IN VALUE
         MOV     M,A      ; PUT BYTE BACK
         RET
 STH05:
         MOV     A,M      ; IF UPPER HALF, GET BYTE
         ANI     0FH      ; CLEAR UPPER 4 BITS
         MOV     B,A      ; SAVE BYTE IN B
         MOV     A,C      ; GET VALUE
         RRC
         RRC
         RRC
         RRC              ; ALIGN TO UPPER 4 BITS
         ORA     B        ; OR IN ORIGINAL LOWER 4 BITS
         MOV     M,A      ; PUT NEW CONFIGURATION BACK
         RET
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: VALDG
 ; INPUTS: C - ASCII CHARACTER
 ; OUTPUTS: CARRY - 1 IF CHARACTER REPRESENTS VALID HEX DIGIT
 ;                - 0 OTHERWISE
 ; CALLS: NOTHING
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: VALDG RETURNS SUCCESS IF ITS INPUT ARGUMENT IS
 ;              AN ASCII CHARACTER REPRESENTING A VALID HEX DIGIT
 ;              (0-9,A-F), AND FAILURE OTHERWISE.
 ;
 VALDG:
         MOV     A,C
         CPI     '0'      ; TEST CHARACTER AGAINST '0'
         JM      FRET     ; IF ASCII CODE LESS, CANNOT BE VALID DIGIT
         CPI     '9'      ; ELSE, SEE IF IN RANGE
         JM      SRET     ; CODE BETWEEN '0' AND '9'
         JZ      SRET     ; CODE EQUAL '9'
         CPI     'A'      ; NOT A DIGIT - TRY FOR A LETTER
         JM      FRET     ; NO - CODE BETWEEN '9' AND 'A'
         CPI     'G'
         JP      FRET     ; NO - CODE GREATER THAN 'F'
         JMP     SRET     ; OKAY - CODE IS 'A' TO 'F', INCLUSIVE
 ;
 ;
 ;
 ;
 ;
 ; FUNCTION: VALDL
 ; INPUTS: C - CHARACTER
 ; OUTPUTS: CARRY - 1 IF INPUT ARGUMENT VALID DELIMTER
 ;                - 0 OTHERWISE
 ; CALLS: NOTHING
 ; DESTROYS: A,F/F'S
 ; DESCRIPTION: VALDL RETURNS SUCCESS IF ITS INPUT ARGUMENT IS A VALID
 ;              DELIMITER CHARACTER (SPACE, COMMA, CARRIAGE RETURN) AND
 ;              FAILURE OTHERWISE.
 ;
 VALDL:
         MOV     A,C
         CPI     ','      ; CHECK FOR COMMA
         JZ      SRET
         CPI     CR       ; CHECK FOR CARRIAGE RETURN
         JZ      SRET
         CPI     ' '      ; CHECK FOR SPACE
         JZ      SRET
         JMP     FRET     ; ERROR IF NONE OF THE ABOVE
 ;
 ;
 ;
 ;
 ;
 ; MONITOR TABLES
 ;
 ;
 ;
 ;
 ;
 SGNON:           ; SIGNON MESSAGE
         DB      CR,LF,'SDK-85 VER 2.1',CR,LF







 LSGNON  EQU      $-SGNON ; LENGTH OF SIGNON MESSAGE
 ;
 CADR:            ; TABLE OF ADDRESSES OF COMMAND ROUTINES
         DW      0        ; DUMMY
         DW      XCMD
         DW      SCMD
         DW      MCMD
         DW      ICMD
         DW      GCMD
         DW      DCMD
 ;
 CTAB:            ; TABLE OF VALID COMMAND CHARACTERS
         DB      'D'
         DB      'G'
         DB      'I'
         DB      'M'
         DB      'S'
         DB      'X'
 NCMDS   EQU      $-CTAB ; NUMBER OF VALID COMMANDS
 ;
 DIGTB:           ; TABLE OF PRINT VALUES OF HEX DIGITS
         DB      '0'
         DB      '1'
         DB      '2'
         DB      '3'
         DB      '4'
         DB      '5'
         DB      '6'
         DB      '7'
         DB      '8'
         DB      '9'
         DB      'A'
         DB      'B'
         DB      'C'
         DB      'D'
         DB      'E'
         DB      'F'
 ;
 RTAB:            ; TABLE OF REGISTER INFORMATION
         DB      'A'               ; REGISTER IDENTIFIER
         DB      ASAV     AND 0FFH ; ADDRESS OF REGISTER SAVE LOCATION
         DB      0                 ; LENGTH FLAG - 0=8 BITS, 1=16 BITS
 RTABS   EQU      $-RTAB           ; SIZE OF AN ENTRY IN THIS TABLE
         DB      'B'
         DB      BSAV     AND 0FFH
         DB      0
         DB      'C'
         DB      CSAV     AND 0FFH
         DB      0
         DB      'D'
         DB      DSAV     AND 0FFH
         DB      0
         DB      'E'
         DB      ESAV     AND 0FFH
         DB      0
         DB      'F'
         DB      FSAV     AND 0FFH
         DB      0
         DB      'I'
         DB      ISAV     AND 0FFH
         DB      0
         DB      'H'
         DB      HSAV     AND 0FFH
         DB      0
         DB      'L'
         DB      LSAV     AND 0FFH
         DB      0
         DB      'M'
         DB      HSAV     AND 0FFH
         DB      1
         DB      'S'
         DB      SSAV+1   AND 0FFH
         DB      1
         DB      'P'
         DB      PSAV+1   AND 0FFH
         DB      1
         DB      0        ; END OF TABLE MARKERS
         DB      0
 ;
         ORG     BRTAB    ; BRANCH TABLE FOR USER ACCESSIBLE ROUTINES
 ;
         JMP     CO       ; TTY CONSOLE OUTPUT
         JMP     CI       ; TTY CONSOLE INPUT
 ;
 ;
 ;
 ; IN THE FOLLOWING LOCATIONS, THE USER MAY PLACE JUMP INSTRUCTIONS TO
 ; ROUTINES FOR HANDLING THE FOLLOWING:-
 ;       A) RST 5, 6 & 7 INSTRUCTIONS
 ;       B) HARDWIRED USER INTERRUPT (RST 6.5)
 ;       C) KEYBOARD "VECTORED INTERRUPT" KEY (RST 7.5)
 ;
         ORG     USRBR    ; START OF USER BRANCH LOCATIONS
 ;
 RSET5:  DB       0,0,0 ; JUMP TO RST 5 ROUTINE


 RSET6:  DB       0,0,0 ; JUMP TO RST 6 ROUTINE


 RST65:  DB       0,0,0 ; JUMP TO RST 6.5 (HARDWIRED USER INTERRUPT)


 RSET7:  DB       0,0,0 ; JUMP TO RST 7 ROUTINE


 USINT:  DB       0,0,0 ; JUMP TO "VECTORED INTERRUPT" KEY ROUTINE


 ;
 ;
 ;
 ; SPACE IS RESERVED HERE FOR THE MONITOR STACK
 ;
 ;
 ;
         ORG     MNSTK    ; START OF MONITOR STACK
 ;
 ; SAVE LOCATIONS FOR USER REGISTERS
 ;
 ESAV:   DB       0 ; E REGISTER
 DSAV:   DB       0 ; D REGISTER
 CSAV:   DB       0 ; C REGISTER
 BSAV:   DB       0 ; B REGISTER
 FSAV:   DB       0 ; FLAGS
 ASAV:   DB       0 ; A REGISTER
 LSAV:   DB       0 ; L REGISTER
 HSAV:   DB       0 ; H REGISTER
 ISAV:   DB       0 ; INTERRUPT MASK
 PSAV:              ; PROGRAM COUNTER
 PCLSV:  DB       0 ; LOW ORDER BYTE
 PCHSV:  DB       0 ; HIGH ORDER BYTE
 SSAV:              ; STACK POINTER
 SPLSV:  DB       0 ; LOW ORDER BYTE
 SPHSV:  DB       0 ; HIGH ORDER BYTE
 ;
 ;
 ;
 ; MONITOR STORAGE LOCATIONS
 ;
 CURAD:  DW       0 ; CURRENT ADDRESS
 CURDT:  DB       0 ; CURRENT DATA
 OBUFF:  DS       4 ; OUTPUT BUFFER
 TEMP:              ; TEMPORARY LOCATION FOR TTY MONITOR
                    ; TEMPORARY LOCATION FOR SINGLE STEP ROUTINE
 RGPTR:  DB       0 ; REGISTER POINTER
 IBUFF:  DB       0 ; INPUT BUFFER
 USCSR:  DB       0 ; USER SHOULD STORE IMAGE OF CSR HERE EACH TIME
                    ; /CSR IS CHANGED. OTHERWISE, SINGLE STEP
                    ; /ROUTINE WILL DESTROY CSR CONTENTS.
         END
